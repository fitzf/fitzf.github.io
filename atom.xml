<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhangfei&#39;s blog</title>
  <subtitle>Quick notes</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhangfei.tk/"/>
  <updated>2017-07-07T15:12:45.000Z</updated>
  <id>http://zhangfei.tk/</id>
  
  <author>
    <name>Zhang Fei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于Docker的CI/CD流水线实践</title>
    <link href="http://zhangfei.tk/2017/07/07/%E5%9F%BA%E4%BA%8EDocker%E7%9A%84CI-CD%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%AE%9E%E8%B7%B5/"/>
    <id>http://zhangfei.tk/2017/07/07/基于Docker的CI-CD流水线实践/</id>
    <published>2017-07-07T14:56:38.000Z</published>
    <updated>2017-07-07T15:12:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>随着DevOps理念不断的传播，大部分IT从业者对于DevOps本身也有了一定的了解和认识，然而企业内部想根据DevOps思想实践，这并不是一件很简单的事情。一方面由于企业内部的历史环境以及组织结构问题，另外一方面因为业界并没有一套标准的开源工具集可以借鉴（关于几家基于Docker创业的服务提供商暂时除外）。</p>
<p>那么该篇内容主要讲解如何借助开源工具结合CI/CD的场景，将Docker融入到部署单元中去，进行持续集成、测试到最终的持续部署，开发人员最终只需要去关注业务的访问入口就可以知道业务是否正常，并可以通过一系列的监控工具去及时发现业务异常。</p>
<p>在整个DevOps部署流水线中需要以下几个部分：CI部分、CD部分、服务调度(治理)部分、监控部分、日志部分。本篇文章将通过一个简单的go-web应用去进行基于Docker的CI/CD流水线的测试。</p>
<p><img src="/images/pasted-42.png" alt="upload successful"></p>
<h1 id="基于Docker的CI-CD的优势"><a href="#基于Docker的CI-CD的优势" class="headerlink" title="基于Docker的CI/CD的优势"></a>基于Docker的CI/CD的优势</h1><p>一个完整的流程入上图所示，用户（也就是开发人员）将包含Dockerfile的源码从本地push到Git服务器上，然后触发Jenkins进行构建源码，源码构建完成后紧接着进行Docker image的构建，一切构建完成之后，顺带将构建成功的image上传到企业内部的镜像仓库，到此刻为止，其实一个基本的CI（持续集成）已经算是结束，剩下的部分就是持续部署或者进行持续的交付开发产物了。在以前传统的软件发布模式中，持续集成的产物是编译打包好的代码，如果想要发布程序，发布系统需要在持续集成的制品库中去获得对应的代码，然后根据一系列的环境检查来准备应用的运行时环境，而在此过程中往往会涉及到比较多的基本组件依赖，所以在整体的发布周期内来看，还是有一些问题的。在Docker或者容器时代，我们将容器的镜像构建部分融入到持续集成（CI）环节，最终持续集成的产出物是一些已经处理好依赖关系，基本不需要人工进行二次干预的Docker image，而在CD环节，发布系统只需要设置和管理很少的信息就能够很快将image运行起来，快速地将业务发布出去。</p>
<p>在上面整个环节中，其实无非就是增加了Docker的那一层处理，但其实在整个软件开发的生命周期中，它是产生了极大的影响的。首先，部署系统不需要为统一的部署框架去做更多逻辑抽象，业务研发在开发代码的过程中选择自己依赖的base image即可，最终运行起来的业务也就是你当时提供的base image的模样；其次，由于base image已经处理好了相关的依赖，所以当发布系统拿到业务的image的时候，发布操作将会变得异常迅速，这对于互联网时代可谓是非常重要的；最后一点，也是我感受最深的，就是研发构建好的image可以在任何的Docker环境中run起来，研发人员不需要再关系环境一致性的问题，他们在自己本地的测试环境能够运行起来的应用，那么到生成环境也一定可以。</p>
<p>为什么第三点我感触比较深呢？因为以前经常有研发兄弟跑过来跟我们讲，我们代码在本地运行一切顺利，代码给你们上到生产就各种问题。所以如果在整个流程中使用Docker image来讲所有的环境固化，从此mm就再也不用担心和研发兄弟扯皮环境不一致的问题啦。</p>
<h1 id="基于Docker的CI-CD的开源方案实现"><a href="#基于Docker的CI-CD的开源方案实现" class="headerlink" title="基于Docker的CI/CD的开源方案实现"></a>基于Docker的CI/CD的开源方案实现</h1><h2 id="一、自助式Git管理工具Gogs的部署安装"><a href="#一、自助式Git管理工具Gogs的部署安装" class="headerlink" title="一、自助式Git管理工具Gogs的部署安装"></a>一、自助式Git管理工具Gogs的部署安装</h2><p>Gogs部署</p>
<p>Gogs部署在10.0.0.1主机上，映射到宿主机端口为32770</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker run -itd -p 32770:3000 -v /<span class="built_in">export</span>/CI-CD/mygit:/data --name jdjr-gogs gogs:17-04-25</div></pre></td></tr></table></figure>
<p>MySQL建库授权</p>
<p>MySQL部署在10.0.0.2上，映射到宿主机端口为32771</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker run -itd -p 32771:3306 --name jdjr-mysql pandora-mysql</div></pre></td></tr></table></figure>
<p>配置Gogs</p>
<p>上面两步没有问题之后就可以直接访问:ip:32770 （也就是Gogs暴露的端口）进行相关的配置。</p>
<p>配置数据库相关：</p>
<p><img src="/images/pasted-40.png" alt="upload successful"></p>
<p>配置Git地址：</p>
<p><img src="/images/pasted-39.png" alt="upload successful"></p>
<p>配置完成后进行初始化，并创建管理员用户后就可正常使用。</p>
<p>如图，现在正在使用的本地Git。</p>
<p><img src="/images/pasted-38.png" alt="upload successful"></p>
<p>现在就可以将源码托管在本地的Gogs仓库上了。</p>
<h2 id="二、Jenkins持续集成工具部署安装"><a href="#二、Jenkins持续集成工具部署安装" class="headerlink" title="二、Jenkins持续集成工具部署安装"></a>二、Jenkins持续集成工具部署安装</h2><p>Jenkins部署</p>
<p>Jenkins在官方的image基础上增加了go 1.7的编译环境，部署在10.0.0.2上，映射到宿主机端口32791。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker run -itd -p 32791:8080 -p 32790:50000 -v /<span class="built_in">export</span>/jenkins/:/var/jenkine_home/ --name jdjr-jenkins jdjr-jenkins</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：需要将Jenkins相关数据以及编译环境映射到Docker宿主机上，因为后期编译完成后Jenkins容器需要docker build构建业务image。</p>
</blockquote>
<p>Jenkins容器运行起来之后，就可以直接访问10.0.0.2:32791进行初始化安装配置了。</p>
<p>在Web上面访问Jenkins地址进行初始化配置，需要写入ID进行解锁Jenkins（Web上会提示在哪个路径下存放，直接使用docker logs也可查看）；解锁后就是正常的安装相关的Plugins了，只要网络没有问题，一般都正常通过。</p>
<p>Jenkine安装成功后界面如下：</p>
<p><img src="/images/pasted-37.png" alt="upload successful"></p>
<p>创建Jenkins项目，并配置构建脚本（也可通过相应的Plugins进行配置）。</p>
<p>创建一个新的名为test的项目，配置相关的源码管理以及构建条件以及相关的后续操作。</p>
<p><img src="/images/pasted-36.png" alt="upload successful"></p>
<p><img src="/images/pasted-35.png" alt="upload successful"></p>
<p><img src="/images/pasted-34.png" alt="upload successful"></p>
<p>配置Jenkins环境</p>
<p>注意：由上图可以看出来，Jenkins进行构建image和持续部署测试的过程都是通过SSH到远端去执行的，因此需要再Jenkins容器中生成SSH公私钥对，并和Jenkins的宿主机以及持续部署测试的宿主机进行免密认证。虽然Jenkins本身其实支持了很多种Plugin来支持管理Docker的，比如说Docker build step plugin、Docker Build Publish Plugin，但是由于过多的Plugin会造成实际环境中的维护成本大大增加，因此我们选择简单粗暴的脚本方式，上图中的Execute shell只是简单的示例。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker <span class="built_in">exec</span> -it myjenkins bash</div></pre></td></tr></table></figure>
<p>生成公私钥对之后，将公钥传给要远程部署的机器就OK了，目的是要让Jenkins容器能够免密登录远程服务器，并能执行sudo命令。</p>
<h2 id="三、通过配置Nginx反向代理来访问Git，Jenkins以及测试实例"><a href="#三、通过配置Nginx反向代理来访问Git，Jenkins以及测试实例" class="headerlink" title="三、通过配置Nginx反向代理来访问Git，Jenkins以及测试实例"></a>三、通过配置Nginx反向代理来访问Git，Jenkins以及测试实例</h2><p>反向代理Nginx部署在10.0.0.4:80上。</p>
<p>配置Nginx</p>
<blockquote>
<p>注意：centos6.8-jdjr-test-app:v2镜像默认是包含Nginx以及配置管理工具的。</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker run -itd --name biaoge-nginx centos6.8-jdjr-test-app:v2</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：此时Git上的源码还没有编译部署，我只是暂时定义了一个端10.0.0.3:32768，等完成整个CI/CD流程后直接访问web.biao.com就可以看到源码部署的效果。</p>
</blockquote>
<p>测试访问</p>
<p>在本地绑定如下hosts</p>
<blockquote>
<p>10.0.0.4 jenkins.biao.com</p>
</blockquote>
<p>访问mygit.biao.com上面的源码：</p>
<p><img src="/images/pasted-33.png" alt="upload successful"></p>
<p>访问jenkins.biao.com上的构建任务：</p>
<p><img src="/images/pasted-32.png" alt="upload successful"></p>
<p>注意：test项目在之前我们已经配置好了，所以可以直接触发构建部署。<br>手动触发构建部署：</p>
<p><img src="/images/pasted-31.png" alt="upload successful"></p>
<p>注意：在构建过程这里可以看到详细的构建过程，构建成功后便可以访问我们的goweb服务了。<br>访问web.biao.com服务：</p>
<p><img src="/images/pasted-30.png" alt="upload successful"></p>
<p>持续集成持续部署的效果</p>
<p>更新源码中的部分内容，进行重新构建访问。</p>
<p>修改web的源码<br>在Jenkins上进行再次构建：</p>
<p><img src="/images/pasted-29.png" alt="upload successful"></p>
<p><img src="/images/pasted-28.png" alt="upload successful"></p>
<p>再次访问web.biao.com服务：</p>
<p><img src="/images/pasted-27.png" alt="upload successful"></p>
<p>对比前后两个Web，发现不仅欢迎语由“biaoge”变成了“逼格运维说”，而且第二行的字符串由4e7853008397变为0ce402beclle，也就是是之前的那个Container已经被销毁，我们现在访问的web.biao.com是重新编译后运行在新的container里面的实例。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h1&gt;&lt;p&gt;随着DevOps理念不断的传播，大部分IT从业者对于DevOps本身也有了一定的了解和认识，然而企业内部想根据DevOps思想实践，这并不是
    
    </summary>
    
      <category term="Collection" scheme="http://zhangfei.tk/categories/Collection/"/>
    
    
      <category term="DevOps" scheme="http://zhangfei.tk/tags/DevOps/"/>
    
  </entry>
  
  <entry>
    <title>快速切换hosts文件的开源程序SwitchHosts</title>
    <link href="http://zhangfei.tk/2017/07/07/%E5%BF%AB%E9%80%9F%E5%88%87%E6%8D%A2hosts%E6%96%87%E4%BB%B6%E7%9A%84%E5%BC%80%E6%BA%90%E7%A8%8B%E5%BA%8FSwitchHosts/"/>
    <id>http://zhangfei.tk/2017/07/07/快速切换hosts文件的开源程序SwitchHosts/</id>
    <published>2017-07-07T14:44:50.000Z</published>
    <updated>2017-07-07T15:26:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>SwitchHosts 是一款用于快速切换 hosts 文件的开源小程序，基于 MIT 协议开源。拥有Windows版, Linux版和Mac OS 版。基于 Electron 开发，同时使用了 React、Ant Design 以及 CodeMirror 等框架/库。需要 Node.js 环境。</p>
<p><img src="/images/pasted-25.png" alt="upload successful"></p>
<p>功能特性包括：</p>
<ul>
<li>快速切换 hosts</li>
<li>hosts 文件语法高亮</li>
<li>在线/本地 hosts 方案选择</li>
<li>系统托盘图标快速切换</li>
<li>Host文件编辑时，点击行号快速切换注释</li>
<li>macOS: 支持 Alfred workflow 快速切换</li>
</ul>
<blockquote>
<p>Website <a href="https://oldj.github.io/SwitchHosts" target="_blank" rel="external">https://oldj.github.io/SwitchHosts</a><br>Github <a href="https://github.com/oldj/SwitchHosts" target="_blank" rel="external">https://github.com/oldj/SwitchHosts</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SwitchHosts 是一款用于快速切换 hosts 文件的开源小程序，基于 MIT 协议开源。拥有Windows版, Linux版和Mac OS 版。基于 Electron 开发，同时使用了 React、Ant Design 以及 CodeMirror 等框架/库。需要
    
    </summary>
    
      <category term="Collection" scheme="http://zhangfei.tk/categories/Collection/"/>
    
      <category term="Software" scheme="http://zhangfei.tk/categories/Collection/Software/"/>
    
    
      <category term="Hosts" scheme="http://zhangfei.tk/tags/Hosts/"/>
    
      <category term="Software" scheme="http://zhangfei.tk/tags/Software/"/>
    
  </entry>
  
  <entry>
    <title>Docker Swarm 入门</title>
    <link href="http://zhangfei.tk/2017/07/06/Docker-Swarm-%E5%85%A5%E9%97%A8/"/>
    <id>http://zhangfei.tk/2017/07/06/Docker-Swarm-入门/</id>
    <published>2017-07-06T15:23:31.000Z</published>
    <updated>2017-07-06T15:36:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Swarm 在 Docker 1.12 版本之前属于一个独立的项目，在 Docker 1.12 版本发布之后，该项目合并到了 Docker 中，成为 Docker 的一个子命令。目前，Swarm 是 Docker 社区提供的唯一一个原生支持 Docker 集群管理的工具。它可以把多个 Docker 主机组成的系统转换为单一的虚拟 Docker 主机，使得容器可以组成跨主机的子网网络。</p>
</blockquote>
<h2 id="Swarm-认识"><a href="#Swarm-认识" class="headerlink" title="Swarm 认识"></a>Swarm 认识</h2><p>Swarm 是目前 Docker 官方唯一指定（绑定）的集群管理工具。Docker 1.12 内嵌了 swarm mode 集群管理模式。</p>
<p>为了方便演示跨主机网络，我们需要用到一个工具——Docker Machine，这个工具与 Docker Compose、Docker Swarm 并称 Docker 三剑客，下面我们来看看如何安装 Docker Machine：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ curl -L https://github.com/docker/machine/releases/download/v0.9.0-rc2/docker-machine-`uname <span class="_">-s</span>`-`uname -m` &gt;/tmp/docker-machine &amp;&amp;</div><div class="line">    chmod +x /tmp/docker-machine &amp;&amp;</div><div class="line">    sudo cp /tmp/docker-machine /usr/<span class="built_in">local</span>/bin/docker-machine</div></pre></td></tr></table></figure>
<p>安装过程和 Docker Compose 非常类似。现在 Docker 三剑客已经全部到齐了。<br>在开始之前，我们需要了解一些基本概念，有关集群的 Docker 命令如下：</p>
<ul>
<li>docker swarm：集群管理，子命令有 init, join,join-token, leave, update</li>
<li>docker node：节点管理，子命令有 demote, inspect,ls, promote, rm, ps, update</li>
<li>docker service：服务管理，子命令有 create, inspect, ps, ls ,rm , scale, update</li>
<li>docker stack/deploy：试验特性，用于多应用部署，等正式版加进来再说。</li>
</ul>
<h2 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h2><p>首先使用 Docker Machine 创建一个虚拟机作为 manger 节点。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">$ docker-machine create --driver virtualbox manager1                                    </div><div class="line">Running pre-create checks...</div><div class="line">(manager1) Unable to get the latest Boot2Docker ISO release version:  Get https://api.github.com/repos/boot2docker/boot2docker/releases/latest: dial tcp: lookup api.github.com on [::1]:53: server misbehaving</div><div class="line">Creating machine...</div><div class="line">(manager1) Unable to get the latest Boot2Docker ISO release version:  Get https://api.github.com/repos/boot2docker/boot2docker/releases/latest: dial tcp: lookup api.github.com on [::1]:53: server misbehaving</div><div class="line">(manager1) Copying /home/zuolan/.docker/machine/cache/boot2docker.iso to /home/zuolan/.docker/machine/machines/manager1/boot2docker.iso...</div><div class="line">(manager1) Creating VirtualBox VM...</div><div class="line">(manager1) Creating SSH key...</div><div class="line">(manager1) Starting the VM...</div><div class="line">(manager1) Check network to re-create <span class="keyword">if</span> needed...</div><div class="line">(manager1) Found a new host-only adapter: <span class="string">"vboxnet0"</span></div><div class="line">(manager1) Waiting <span class="keyword">for</span> an IP...</div><div class="line">Waiting <span class="keyword">for</span> machine to be running, this may take a few minutes...</div><div class="line">Detecting operating system of created instance...</div><div class="line">Waiting <span class="keyword">for</span> SSH to be available...</div><div class="line">Detecting the provisioner...</div><div class="line">Provisioning with boot2docker...</div><div class="line">Copying certs to the <span class="built_in">local</span> machine directory...</div><div class="line">Copying certs to the remote machine...</div><div class="line">Setting Docker configuration on the remote daemon...</div><div class="line">Checking connection to Docker...</div><div class="line">Docker is up and running!</div><div class="line">To see how to connect your Docker Client to the Docker Engine running on this virtual machine, run: docker-machine env manager1</div></pre></td></tr></table></figure>
<p>查看虚拟机的环境变量等信息，包括虚拟机的 IP 地址：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$  docker-machine env manager1</div><div class="line"><span class="built_in">export</span> DOCKER_TLS_VERIFY=<span class="string">"1"</span></div><div class="line"><span class="built_in">export</span> DOCKER_HOST=<span class="string">"tcp://192.168.99.100:2376"</span></div><div class="line"><span class="built_in">export</span> DOCKER_CERT_PATH=<span class="string">"/home/zuolan/.docker/machine/machines/manager1"</span></div><div class="line"><span class="built_in">export</span> DOCKER_MACHINE_NAME=<span class="string">"manager1"</span></div><div class="line"><span class="comment"># Run this command to configure your shell: </span></div><div class="line"><span class="comment"># eval $(docker-machine env manager1)</span></div></pre></td></tr></table></figure>
<p>然后再创建一个节点作为 work 节点。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker-machine create --driver virtualbox worker1</div></pre></td></tr></table></figure>
<p>现在我们有了两个虚拟主机，使用 Machine 的命令可以查看：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ docker-machine ls                             </div><div class="line">NAME     ACTIVE   DRIVER       STATE    URL                        SWARM  DOCKER   ERRORS</div><div class="line">manager1   -      virtualbox   Running  tcp://192.168.99.100:2376         v1.12.3   </div><div class="line">worker1    -      virtualbox   Running  tcp://192.168.99.101:2376         v1.12.3</div></pre></td></tr></table></figure>
<p>但是目前这两台虚拟主机并没有什么联系，为了把它们联系起来，我们需要 Swarm 登场了。<br>因为我们使用的是 Docker Machine 创建的虚拟机，因此可以使用 docker-machine ssh 命令来操作虚拟机，在实际生产环境中，并不需要像下面那样操作，只需要执行 docker swarm 即可。</p>
<p>把 manager1 加入集群：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ docker-machine ssh manager1 docker swarm init --listen-addr 192.168.99.100:2377 --advertise-addr 192.168.99.100</div><div class="line">Swarm initialized: current node (23lkbq7uovqsg550qfzup59t6) is now a manager.</div><div class="line"></div><div class="line">To add a worker to this swarm, run the following <span class="built_in">command</span>:</div><div class="line"></div><div class="line">    docker swarm join \</div><div class="line">    --token SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-c036gwrakjejql06klrfc585r \</div><div class="line">    192.168.99.100:2377</div><div class="line"></div><div class="line">To add a manager to this swarm, run <span class="string">'docker swarm join-token manager'</span> and follow the instructions.</div></pre></td></tr></table></figure>
<p>用 –listen-addr 指定监听的 ip 与端口，实际的 Swarm 命令格式如下，本例使用 Docker Machine 来连接虚拟机而已：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker swarm init --listen-addr &lt;MANAGER-IP&gt;:&lt;PORT&gt;</div></pre></td></tr></table></figure>
<p>接下来，再把 work1 加入集群中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ docker-machine ssh worker1 docker swarm join --token \</div><div class="line">    SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-c036gwrakjejql06klrfc585r \</div><div class="line">    192.168.99.100:2377</div><div class="line">This node joined a swarm as a worker.</div></pre></td></tr></table></figure>
<p>上面 join 命令中可以添加 –listen-addr $WORKER1_IP:2377 作为监听准备，因为有时候可能会遇到把一个 work 节点提升为 manger 节点的可能，当然本例子没有这个打算就不添加这个参数了。</p>
<blockquote>
<p>注意：如果你在新建集群时遇到双网卡情况，可以指定使用哪个 IP，例如上面的例子会有可能遇到下面的错误。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ docker-machine ssh manager1 docker swarm init --listen-addr <span class="variable">$MANAGER1_IP</span>:2377</div><div class="line">Error response from daemon: could not choose an IP address to advertise since this system has multiple addresses on different interfaces (10.0.2.15 on eth0 and 192.168.99.100 on eth1) - specify one with --advertise-addr</div><div class="line"><span class="built_in">exit</span> status 1</div></pre></td></tr></table></figure>
<p>发生错误的原因是因为有两个 IP 地址，而 Swarm 不知道用户想使用哪个，因此要指定 IP。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ docker-machine ssh manager1 docker swarm init --advertise-addr 192.168.99.100 --listen-addr 192.168.99.100:2377 </div><div class="line">Swarm initialized: current node (ahvwxicunjd0z8g0eeosjztjx) is now a manager.</div><div class="line"></div><div class="line">To add a worker to this swarm, run the following <span class="built_in">command</span>:</div><div class="line"></div><div class="line">    docker swarm join \</div><div class="line">    --token SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-c036gwrakjejql06klrfc585r \</div><div class="line">    192.168.99.100:2377</div><div class="line"></div><div class="line">To add a manager to this swarm, run <span class="string">'docker swarm join-token manager'</span> and follow the instructions.</div></pre></td></tr></table></figure>
<p>集群初始化成功。</p>
<p>现在我们新建了一个有两个节点的“集群”，现在进入其中一个管理节点使用 docker node 命令来查看节点信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ docker-machine ssh manager1 docker node ls</div><div class="line">ID                       HOSTNAME  STATUS  AVAILABILITY  MANAGER STATUS</div><div class="line">23lkbq7uovqsg550qfzup59t6 *  manager1    Ready      Active         Leader</div><div class="line">dqb3fim8zvcob8sycri3hy98a    worker1     Ready      Active</div></pre></td></tr></table></figure>
<p>现在每个节点都归属于 Swarm，并都处在了待机状态。Manager1 是领导者，work1 是工人。</p>
<p>现在，我们继续新建虚拟机 manger2、worker2、worker3，现在已经有五个虚拟机了，使用 docker-machine ls 来查看虚拟机：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NAME     ACTIVE    DRIVER       STATE     URL                         SWARM   DOCKER    ERRORS</div><div class="line">manager1   -       virtualbox   Running   tcp://192.168.99.100:2376           v1.12.3   </div><div class="line">manager2   -       virtualbox   Running   tcp://192.168.99.105:2376           v1.12.3   </div><div class="line">worker1    -       virtualbox   Running   tcp://192.168.99.102:2376           v1.12.3   </div><div class="line">worker2    -       virtualbox   Running   tcp://192.168.99.103:2376           v1.12.3   </div><div class="line">worker3    -       virtualbox   Running   tcp://192.168.99.104:2376           v1.12.3</div></pre></td></tr></table></figure>
<p>然后我们把剩余的虚拟机也加到集群中。</p>
<p>添加 worker2 到集群中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ docker-machine ssh worker2 docker swarm join \</div><div class="line">  --token SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-c036gwrakjejql06klrfc585r \</div><div class="line">  192.168.99.100:2377</div><div class="line">This node joined a swarm as a worker.</div></pre></td></tr></table></figure>
<p>添加 worker3 到集群中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ docker-machine ssh worker3 docker swarm join \</div><div class="line">  --token SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-c036gwrakjejql06klrfc585r \</div><div class="line">  192.168.99.100:2377</div><div class="line">This node joined a swarm as a worker.</div></pre></td></tr></table></figure>
<p>添加 manager2 到集群中：<br>先从 manager1 中获取 manager 的 token：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ docker-machine ssh manager1 docker swarm join-token manager</div><div class="line">To add a manager to this swarm, run the following <span class="built_in">command</span>:</div><div class="line"></div><div class="line">  docker swarm join \</div><div class="line">  --token SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-8tn855hkjdb6usrblo9iu700o \</div><div class="line">192.168.99.100:2377</div></pre></td></tr></table></figure>
<p>然后添加 manager2 到集群中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ docker-machine ssh manager2 docker swarm join \</div><div class="line">  --token SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-8tn855hkjdb6usrblo9iu700o \</div><div class="line">  192.168.99.100:2377</div><div class="line">This node joined a swarm as a manager.</div></pre></td></tr></table></figure>
<p>现在再来查看集群信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ docker-machine ssh manager2 docker node ls</div><div class="line">ID                            HOSTNAME   STATUS   AVAILABILITY   MANAGER STATUS</div><div class="line">16w80jnqy2k30yez4wbbaz1l8     worker1     Ready     Active        </div><div class="line">2gkwhzakejj72n5xoxruet71z     worker2     Ready     Active        </div><div class="line">35kutfyn1ratch55fn7j3fs4x     worker3     Ready     Active        </div><div class="line">a9r21g5iq1u6h31myprfwl8ln *   manager2    Ready     Active        Reachable</div><div class="line">dpo7snxbz2a0dxvx6mf19p35z     manager1    Ready     Active        Leader</div></pre></td></tr></table></figure>
<h2 id="建立跨主机网络"><a href="#建立跨主机网络" class="headerlink" title="建立跨主机网络"></a>建立跨主机网络</h2><p>为了演示更清晰，下面我们把宿主机也加入到集群之中，这样我们使用 Docker 命令操作会清晰很多。<br>直接在本地执行加入集群命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ docker swarm join \           </div><div class="line">    --token SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-8tn855hkjdb6usrblo9iu700o \</div><div class="line">    192.168.99.100:2377</div><div class="line">This node joined a swarm as a manager.</div></pre></td></tr></table></figure>
<p>现在我们有三台 manager，三台 worker。其中一台是宿主机，五台虚拟机。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ docker node ls</div><div class="line">ID                          HOSTNAME    STATUS    AVAILABILITY  MANAGER STATUS</div><div class="line">6z2rpk1t4xucffzlr2rpqb8u3    worker3     Ready     Active        </div><div class="line">7qbr0xd747qena4awx8bx101s *  user-pc     Ready     Active         Reachable</div><div class="line">9v93sav79jqrg0c7051rcxxev    manager2    Ready     Active         Reachable</div><div class="line">a1ner3zxj3ubsiw4l3p28wrkj    worker1     Ready     Active        </div><div class="line">a5w7h8j83i11qqi4vlu948mad    worker2     Ready     Active        </div><div class="line">d4h7vuekklpd6189fcudpfy18    manager1    Ready     Active          Leader</div></pre></td></tr></table></figure>
<p>查看网络状态：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ docker network ls</div><div class="line">NETWORK ID         NAME            DRIVER          SCOPE</div><div class="line">764ff31881e5        bridge          bridge          <span class="built_in">local</span>                  </div><div class="line">fbd9a977aa03        host            host            <span class="built_in">local</span>               </div><div class="line">6p6xlousvsy2        ingress         overlay         swarm            </div><div class="line">e81af24d643d        none            null            <span class="built_in">local</span></div></pre></td></tr></table></figure>
<p>可以看到在 swarm 上默认已有一个名为 ingress 的 overlay 网络, 默认在 swarm 里使用，本例子中会创建一个新的 overlay 网络。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ docker network create --driver overlay swarm_test</div><div class="line">4dm8cy9y5delvs5vd0ghdd89s</div><div class="line">$ docker network ls</div><div class="line">NETWORK ID         NAME                DRIVER              SCOPE</div><div class="line">764ff31881e5        bridge              bridge              <span class="built_in">local</span></div><div class="line">fbd9a977aa03        host                host                <span class="built_in">local</span></div><div class="line">6p6xlousvsy2        ingress             overlay             swarm</div><div class="line">e81af24d643d        none                null                <span class="built_in">local</span></div><div class="line">4dm8cy9y5del        swarm_test          overlay             swarm</div></pre></td></tr></table></figure>
<p>这样一个跨主机网络就搭建好了，但是现在这个网络只是处于待机状态，下一小节我们会在这个网络上部署应用。</p>
<h2 id="在跨主机网络上部署应用"><a href="#在跨主机网络上部署应用" class="headerlink" title="在跨主机网络上部署应用"></a>在跨主机网络上部署应用</h2><p>首先我们上面创建的节点都是没有镜像的，因此我们要逐一 pull 镜像到节点中，这里我们使用前面搭建的私有仓库。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">$ docker-machine ssh manager1 docker pull reg.example.com/library/nginx:alpine     </div><div class="line">alpine: Pulling from library/nginx</div><div class="line">e110a4a17941: Pulling fs layer</div><div class="line">... ...</div><div class="line">7648f5d87006: Pull complete</div><div class="line">Digest: sha256:65063cb82bf508fd5a731318e795b2abbfb0c22222f02ff5c6b30df7f23292fe</div><div class="line">Status: Downloaded newer image <span class="keyword">for</span> reg.example.com/library/nginx:alpine</div><div class="line">$ docker-machine ssh manager2 docker pull reg.example.com/library/nginx:alpine</div><div class="line">alpine: Pulling from library/nginx</div><div class="line">e110a4a17941: Pulling fs layer</div><div class="line">... ...</div><div class="line">7648f5d87006: Pull complete</div><div class="line">Digest: sha256:65063cb82bf508fd5a731318e795b2abbfb0c22222f02ff5c6b30df7f23292fe</div><div class="line">Status: Downloaded newer image <span class="keyword">for</span> reg.example.com/library/nginx:alpine</div><div class="line">$ docker-machine ssh worker1 docker pull reg.example.com/library/nginx:alpine </div><div class="line">alpine: Pulling from library/nginx</div><div class="line">e110a4a17941: Pulling fs layer</div><div class="line">... ...</div><div class="line">7648f5d87006: Pull complete</div><div class="line">Digest: sha256:65063cb82bf508fd5a731318e795b2abbfb0c22222f02ff5c6b30df7f23292fe</div><div class="line">Status: Downloaded newer image <span class="keyword">for</span> reg.example.com/library/nginx:alpine</div><div class="line">$ docker-machine ssh worker2 docker pull reg.example.com/library/nginx:alpine</div><div class="line">alpine: Pulling from library/nginx</div><div class="line">e110a4a17941: Pulling fs layer</div><div class="line">... ...</div><div class="line">7648f5d87006: Pull complete</div><div class="line">Digest: sha256:65063cb82bf508fd5a731318e795b2abbfb0c22222f02ff5c6b30df7f23292fe</div><div class="line">Status: Downloaded newer image <span class="keyword">for</span> reg.example.com/library/nginx:alpine</div><div class="line">$ docker-machine ssh worker3 docker pull reg.example.com/library/nginx:alpine</div><div class="line">alpine: Pulling from library/nginx</div><div class="line">e110a4a17941: Pulling fs layer</div><div class="line">... ...</div><div class="line">7648f5d87006: Pull complete</div><div class="line">Digest: sha256:65063cb82bf508fd5a731318e795b2abbfb0c22222f02ff5c6b30df7f23292fe</div><div class="line">Status: Downloaded newer image <span class="keyword">for</span> reg.example.com/library/nginx:alpine</div></pre></td></tr></table></figure>
<p>上面使用 docker pull 分别在五个虚拟机节点拉取 nginx:alpine 镜像。接下来我们要在五个节点部署一组 Nginx 服务。</p>
<p>部署的服务使用 swarm_test 跨主机网络。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ docker service create --replicas 2 --name helloworld --network=swarm_test nginx:alpine</div><div class="line">5gz0h2s5agh2d2libvzq6bhgs</div></pre></td></tr></table></figure>
<p>查看服务状态：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ docker service ls</div><div class="line">ID            NAME        REPLICAS  IMAGE         COMMAND</div><div class="line">5gz0h2s5agh2  helloworld  0/2       nginx:alpine</div></pre></td></tr></table></figure>
<p>查看 helloworld 服务详情（为了方便阅读，已调整输出内容）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ docker service ps helloworld</div><div class="line">ID          NAME          IMAGE         NODE      DESIRED STATE   CURRENT STATE              ERROR</div><div class="line">ay081uome3   helloworld.1  nginx:alpine  manager1  Running         Preparing 2 seconds ago  </div><div class="line">16cvore0c96  helloworld.2  nginx:alpine  worker2   Running         Preparing 2 seconds ago</div></pre></td></tr></table></figure>
<p>可以看到两个实例分别运行在两个节点上。</p>
<p>进入两个节点，查看服务状态（为了方便阅读，已调整输出内容）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ docker-machine ssh manager1 docker ps <span class="_">-a</span></div><div class="line">CONTAINER ID   IMAGE         COMMAND         CREATED        STATUS         PORTS            NAMES</div><div class="line">119f787622c2   nginx:alpine  <span class="string">"nginx -g ..."</span>   4 minutes ago  Up 4 minutes   80/tcp, 443/tcp  hello ...</div><div class="line">$ docker-machine ssh worker2 docker ps <span class="_">-a</span></div><div class="line">CONTAINER ID   IMAGE         COMMAND         CREATED         STATUS        PORTS             NAMES</div><div class="line">5db707401a06   nginx:alpine  <span class="string">"nginx -g ..."</span>   4 minutes ago   Up 4 minutes  80/tcp, 443/tcp   hello ...</div></pre></td></tr></table></figure>
<p>上面输出做了调整，实际的 NAMES 值为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">helloworld.1.ay081uome3eejeg4mspa8pdlx</div><div class="line">helloworld.2.16cvore0c96rby1vp0sny3mvt</div></pre></td></tr></table></figure>
<p>记住上面这两个实例的名称。现在我们来看这两个跨主机的容器是否能互通：<br>首先使用 Machine 进入 manager1 节点，然后使用 docker exec -i 命令进入 helloworld.1 容器中 ping 运行在 worker2 节点的 helloworld.2 容器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ docker-machine ssh manager1 docker <span class="built_in">exec</span> -i helloworld.1.ay081uome3eejeg4mspa8pdlx \</div><div class="line">    ping helloworld.2.16cvore0c96rby1vp0sny3mvt</div><div class="line">PING helloworld.2.16cvore0c96rby1vp0sny3mvt (10.0.0.4): 56 data bytes</div><div class="line">64 bytes from 10.0.0.4: seq=0 ttl=64 time=0.591 ms</div><div class="line">64 bytes from 10.0.0.4: seq=1 ttl=64 time=0.594 ms</div><div class="line">64 bytes from 10.0.0.4: seq=2 ttl=64 time=0.624 ms</div><div class="line">64 bytes from 10.0.0.4: seq=3 ttl=64 time=0.612 ms</div><div class="line">^C</div></pre></td></tr></table></figure>
<p>然后使用 Machine 进入 worker2 节点，然后使用 docker exec -i 命令进入 helloworld.2 容器中 ping 运行在 manager1 节点的 helloworld.1 容器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ docker-machine ssh worker2 docker <span class="built_in">exec</span> -i helloworld.2.16cvore0c96rby1vp0sny3mvt \</div><div class="line">    ping helloworld.1.ay081uome3eejeg4mspa8pdlx </div><div class="line">PING helloworld.1.ay081uome3eejeg4mspa8pdlx (10.0.0.3): 56 data bytes</div><div class="line">64 bytes from 10.0.0.3: seq=0 ttl=64 time=0.466 ms</div><div class="line">64 bytes from 10.0.0.3: seq=1 ttl=64 time=0.465 ms</div><div class="line">64 bytes from 10.0.0.3: seq=2 ttl=64 time=0.548 ms</div><div class="line">64 bytes from 10.0.0.3: seq=3 ttl=64 time=0.689 ms</div><div class="line">^C</div></pre></td></tr></table></figure>
<p>可以看到这两个跨主机的服务集群里面各个容器是可以互相连接的。</p>
<p>为了体现 Swarm 集群的优势，我们可以使用虚拟机的 ping 命令来测试对方虚拟机内的容器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$ docker-machine ssh worker2 ping helloworld.1.ay081uome3eejeg4mspa8pdlx</div><div class="line">PING helloworld.1.ay081uome3eejeg4mspa8pdlx (221.179.46.190): 56 data bytes</div><div class="line">64 bytes from 221.179.46.190: seq=0 ttl=63 time=48.651 ms</div><div class="line">64 bytes from 221.179.46.190: seq=1 ttl=63 time=63.239 ms</div><div class="line">64 bytes from 221.179.46.190: seq=2 ttl=63 time=47.686 ms</div><div class="line">64 bytes from 221.179.46.190: seq=3 ttl=63 time=61.232 ms</div><div class="line">^C</div><div class="line">$ docker-machine ssh manager1 ping helloworld.2.16cvore0c96rby1vp0sny3mvt</div><div class="line">PING helloworld.2.16cvore0c96rby1vp0sny3mvt (221.179.46.194): 56 data bytes</div><div class="line">64 bytes from 221.179.46.194: seq=0 ttl=63 time=30.150 ms</div><div class="line">64 bytes from 221.179.46.194: seq=1 ttl=63 time=54.455 ms</div><div class="line">64 bytes from 221.179.46.194: seq=2 ttl=63 time=73.862 ms</div><div class="line">64 bytes from 221.179.46.194: seq=3 ttl=63 time=53.171 ms</div><div class="line">^C</div></pre></td></tr></table></figure>
<p>上面我们使用了虚拟机内部的 ping 去测试容器的延迟，可以看到延迟明显比集群内部的 ping 值要高。</p>
<h2 id="Swarm-集群负载"><a href="#Swarm-集群负载" class="headerlink" title="Swarm 集群负载"></a>Swarm 集群负载</h2><p>现在我们已经学会了 Swarm 集群的部署方法，现在来搭建一个可访问的 Nginx 集群吧。体验最新版的 Swarm 所提供的自动服务发现与集群负载功能。<br>首先删掉上一节我们启动的 helloworld 服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ docker service rm helloworld                                 </div><div class="line">helloworld</div></pre></td></tr></table></figure>
<p>然后在新建一个服务，提供端口映射参数，使得外界可以访问这些 Nginx 服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ docker service create --replicas 2 --name helloworld -p 7080:80 --network=swarm_test nginx:alpine</div><div class="line">9gfziifbii7a6zdqt56kocyun</div></pre></td></tr></table></figure>
<p>查看服务运行状态：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ docker service ls                                                                                </div><div class="line">ID           NAME         REPLICAS     IMAGE           COMMAND</div><div class="line">9gfziifbii7a  helloworld     2/2        nginx:alpine</div></pre></td></tr></table></figure>
<p>不知你有没有发现，虽然我们使用 –replicas 参数的值都是一样的，但是上一节中获取服务状态时，REPLICAS 返回的是 0/2，现在的 REPLICAS 返回的是 2/2。<br>同样使用 docker service ps 查看服务详细状态时（下面输出已经手动调整为更易读的格式），可以看到实例的 CURRENT STATE 中是 Running 状态的，而上一节中的 CURRENT STATE 中全部是处于 Preparing 状态。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ docker service ps helloworld</div><div class="line">ID          NAME      IMAGE     NODE    DESIRED STATE   CURRENT STATE    ERROR</div><div class="line">9ikr3agyi...   helloworld.1  nginx:alpine  user-pc    Running         Running 13 seconds ago  </div><div class="line">7acmhj0u...   helloworld.2  nginx:alpine  worker2    Running         Running 6 seconds ago</div></pre></td></tr></table></figure>
<p>这就涉及到 Swarm 内置的发现机制了，目前 Docker 1.12 中 Swarm 已经内置了服务发现工具，我们不再需要像以前使用 Etcd 或者 Consul 这些工具来配置服务发现。对于一个容器来说如果没有外部通信但又是运行中的状态会被服务发现工具认为是 Preparing 状态，本小节例子中因为映射了端口，因此有了 Running 状态。<br>现在我们来看 Swarm 另一个有趣的功能，当我们杀死其中一个节点时，会发生什么。<br>首先 kill 掉 worker2 的实例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ docker-machine ssh worker2 docker <span class="built_in">kill</span> helloworld.2.7acmhj0udzusv1d7lu2tbuhu4</div><div class="line">helloworld.2.7acmhj0udzusv1d7lu2tbuhu4</div></pre></td></tr></table></figure>
<p>稍等几秒，再来看服务状态：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ docker service ps helloworld</div><div class="line">ID         NAME          IMAGE     NODE   DESIRED STATE  CURRENT STATE   ERROR</div><div class="line">9ikr3agyi...  helloworld.1     nginx:alpine  zuolan-pc  Running       Running 19 minutes ago  </div><div class="line">8f866igpl...  helloworld.2     nginx:alpine  manager1  Running       Running 4 seconds ago   </div><div class="line">7acmhj0u...   \_ helloworld.2  nginx:alpine  worker2   Shutdown       Failed 11 seconds ago  ...exit...</div><div class="line">$ docker service ls           </div><div class="line">ID            NAME        REPLICAS  IMAGE         COMMAND</div><div class="line">9gfziifbii7a  helloworld  2/2       nginx:alpine</div></pre></td></tr></table></figure>
<p>可以看到即使我们 kill 掉其中一个实例，Swarm 也会迅速把停止的容器撤下来，同时在节点中启动一个新的实例顶上来。这样服务依旧还是两个实例在运行。<br>此时如果你想添加更多实例可以使用 scale 命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ docker service scale helloworld=3</div><div class="line">helloworld scaled to 3</div></pre></td></tr></table></figure>
<p>查看服务详情，可以看到有三个实例启动了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ docker service ps helloworld</div><div class="line">ID         NAME        IMAGE      NODE   DESIRED STATE  CURRENT STATE    ERROR</div><div class="line">9ikr3agyi...  helloworld.1    nginx:alpine  user-pc   Running        Running 30 minutes ago  8f866igpl...  helloworld.2    nginx:alpine  manager1  Running        Running 11 minutes ago  7acmhj0u...  \_ helloworld.2  nginx:alpine  worker2   Shutdown       Failed 11 minutes ago   <span class="built_in">exit</span>137</div><div class="line">1vexr1jm...  helloworld.3    nginx:alpine   worker2   Running       Running 4 seconds ago</div></pre></td></tr></table></figure>
<p>现在如果想减少实例数量，一样可以使用 scale 命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ docker service scale helloworld=2</div><div class="line">helloworld scaled to 2</div></pre></td></tr></table></figure>
<p>至此，Swarm的主要用法都已经介绍完了，主要讲述了 Swarm 集群网络的创建与部署。介绍了 Swarm 的常规应用，包括 Swarm 的服务发现、负载均衡等，然后使用 Swarm 来配置跨主机容器网络，并在上面部署应用。</p>
<blockquote>
<p>转自： <a href="http://www.jianshu.com/p/9eb9995884a5" target="_blank" rel="external">http://www.jianshu.com/p/9eb9995884a5</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Swarm 在 Docker 1.12 版本之前属于一个独立的项目，在 Docker 1.12 版本发布之后，该项目合并到了 Docker 中，成为 Docker 的一个子命令。目前，Swarm 是 Docker 社区提供的唯一一个原生支持 Doc
    
    </summary>
    
      <category term="Collection" scheme="http://zhangfei.tk/categories/Collection/"/>
    
    
      <category term="Docker" scheme="http://zhangfei.tk/tags/Docker/"/>
    
      <category term="Docker Swarm" scheme="http://zhangfei.tk/tags/Docker-Swarm/"/>
    
  </entry>
  
  <entry>
    <title>MyCLI：一个支持自动补全和语法高亮的MySQL客户端</title>
    <link href="http://zhangfei.tk/2017/06/07/MyCLI%EF%BC%9A%E4%B8%80%E4%B8%AA%E6%94%AF%E6%8C%81%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%E5%92%8C%E8%AF%AD%E6%B3%95%E9%AB%98%E4%BA%AE%E7%9A%84MySQL%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    <id>http://zhangfei.tk/2017/06/07/MyCLI：一个支持自动补全和语法高亮的MySQL客户端/</id>
    <published>2017-06-07T09:24:06.000Z</published>
    <updated>2017-07-05T14:45:54.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/pasted-19.png" alt="upload successful"><br>MyCLI 是一个易于使用的命令行客户端，可用于受欢迎的数据库管理系统 MySQL、MariaDB 和 Percona，支持自动补全和语法高亮。它是使用 prompt_toolkit 库写的，需要 Python 2.7、3.3、3.4、3.5 和 3.6 的支持。MyCLI 还支持通过 SSL 安全连接到 MySQL 服务器。</p>
<h2 id="MyCLI-的特性"><a href="#MyCLI-的特性" class="headerlink" title="MyCLI 的特性"></a>MyCLI 的特性</h2><ul>
<li>当你第一次使用它的时候，将会自动创建一个文件 ~/.myclirc。</li>
<li>当输入 SQL 的关键词和数据库中的表、视图和列时，支持自动补全。</li>
<li>默认情况下也支持智能补全，能根据上下文的相关性提供补全建议。</li>
</ul>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SELECT * FROM &lt;Tab&gt; - 这将显示出数据库中的表名。</div><div class="line">SELECT * FROM users WHERE &lt;Tab&gt; - 这将简单的显示出列名称。</div></pre></td></tr></table></figure>
<ul>
<li>通过使用 Pygents 支持语法高亮</li>
<li>支持 SSL 连接</li>
<li>提供多行查询支持</li>
<li>它可以将每一个查询和输出记录到一个文件中（默认情况下禁用）。</li>
<li>允许保存收藏一个查询（使用 \fs 别名 保存一个查询，并可使用 \f 别名 运行它）。</li>
<li>支持 SQL 语句执行和表查询计时</li>
<li>以更吸引人的方式打印表格数据</li>
</ul>
<h2 id="如何在-Linux-上为-MySQL-和-MariaDB-安装-MyCLI"><a href="#如何在-Linux-上为-MySQL-和-MariaDB-安装-MyCLI" class="headerlink" title="如何在 Linux 上为 MySQL 和 MariaDB 安装 MyCLI"></a>如何在 Linux 上为 MySQL 和 MariaDB 安装 MyCLI</h2><p>在 Debian/Ubuntu 发行版上，你可以很容易的像下面这样使用 apt 命令 来安装 MyCLI 包：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get update</div><div class="line">$ sudo apt-get install mycli</div></pre></td></tr></table></figure>
<p>同样，在 Fedora 22+ 上也有 MyCLI 的可用包，你可以像下面这样使用 dnf 命令 来安装它：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo dnf install mycli</div></pre></td></tr></table></figure>
<p>对于其他 Linux 发行版，比如 RHEL/CentOS，你需要使用 Python 的 pip 工具来安装 MyCLI。首先，使用下面的命令来安装 pip：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo yum install pip</div></pre></td></tr></table></figure>
<p>安装好 pip 以后，你可以像下面这样安装 MyCLI：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo pip install mycli</div></pre></td></tr></table></figure>
<h2 id="在-Linux-中如何使用-MyCLI-连接-MySQL-和-MariaDB"><a href="#在-Linux-中如何使用-MyCLI-连接-MySQL-和-MariaDB" class="headerlink" title="在 Linux 中如何使用 MyCLI 连接 MySQL 和 MariaDB"></a>在 Linux 中如何使用 MyCLI 连接 MySQL 和 MariaDB</h2><p>安装好 MyCLI 以后，你可以像下面这样使用它：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mycli -u root -h localhost</div></pre></td></tr></table></figure>
<h2 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h2><p>对于关键词和 SQL 函数可以进行简单的自动补全：</p>
<p><img src="/images/pasted-20.png" alt="upload successful"></p>
<h2 id="智能补全"><a href="#智能补全" class="headerlink" title="智能补全"></a>智能补全</h2><p>当输入 FROM 关键词以后会进行表名称的补全：</p>
<p><img src="/images/pasted-21.png" alt="upload successful"></p>
<h2 id="别名支持"><a href="#别名支持" class="headerlink" title="别名支持"></a>别名支持</h2><p>当表的名称设置别名以后，也支持列名称的补全：</p>
<p><img src="/images/pasted-22.png" alt="upload successful"></p>
<h2 id="语法高亮"><a href="#语法高亮" class="headerlink" title="语法高亮"></a>语法高亮</h2><p>支持 MySQL 语法高亮：</p>
<p><img src="/images/pasted-23.png" alt="upload successful"></p>
<h2 id="格式化-SQL-的输出"><a href="#格式化-SQL-的输出" class="headerlink" title="格式化 SQL 的输出"></a>格式化 SQL 的输出</h2><p>MySQL 的输出会通过 less 命令[1] 进行格式化输出：</p>
<p><img src="/images/pasted-24.png" alt="upload successful"></p>
<p>要登录 MySQL 并同时选择数据库，你可以使用和下面类似的命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ mycli local_database</div><div class="line">$ mycli -h localhost -u root app_db</div><div class="line">$ mycli mysql://amjith@localhost:3306/django_poll</div></pre></td></tr></table></figure>
<p>更多使用选项，请输入：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mycli --help</div></pre></td></tr></table></figure>
<blockquote>
<p>MyCLI 主页： <a href="http://mycli.net/index" target="_blank" rel="external">http://mycli.net/index</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/pasted-19.png&quot; alt=&quot;upload successful&quot;&gt;&lt;br&gt;MyCLI 是一个易于使用的命令行客户端，可用于受欢迎的数据库管理系统 MySQL、MariaDB 和 Percona，支持自动补全和语法高亮。它是使用
    
    </summary>
    
      <category term="Collection" scheme="http://zhangfei.tk/categories/Collection/"/>
    
    
      <category term="Mysql" scheme="http://zhangfei.tk/tags/Mysql/"/>
    
      <category term="Shell" scheme="http://zhangfei.tk/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>你应该知道的5个Docker实用工具</title>
    <link href="http://zhangfei.tk/2017/05/27/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%845%E4%B8%AADocker%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    <id>http://zhangfei.tk/2017/05/27/你应该知道的5个Docker实用工具/</id>
    <published>2017-05-27T05:44:37.000Z</published>
    <updated>2017-07-05T14:45:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>【摘要】网上有很多不错的Docker工具，大部分在github上都是开源的。最近两年，我一直在使用Docker，并将其应用到了一些开发项目上。如果你刚开始使用Docker，你会发现它能应用到的实例远远多于预想。Docker能为你做更多，不会让你失望的！</p>
<p>Docker社区非常活跃，每天都有许多新的实用工具出现。因此，天天去检查更新，试图跟上社区的步伐确实有点困难。所以我在此分享在工作中收集到的一些有趣而实用的Docker工具，帮助大家提高日常工作效率。</p>
<p>下面开始一一介绍我在使用Docker的过程中找到的有用工具吧。</p>
<h3 id="watchtower：自动更新Docker容器"><a href="#watchtower：自动更新Docker容器" class="headerlink" title="watchtower：自动更新Docker容器"></a>watchtower：自动更新Docker容器</h3><p>watchtower监视容器运行过程，并且能够捕捉到容器中的变化。当watchtower检测到有镜像发生变化，会自动使用新镜像重启容器。我在本地开发环境中创建的最后一个镜像就用到了watchtower。</p>
<p>watchtower本身就像一个Docker镜像，所以它启动容器的方式和别的镜像无异。运行watchtower的命令如下：</p>
<p><img src="/images/pasted-4.png" alt="upload successful"></p>
<p>上面的代码中，我们用到了一个安装文件/var/run/docker.sock。这个文件主要用来使watchtower与Docker后台API交互。 interval30秒的选项主要用来定义watchtower的轮询间隔时间。watchtower还支持一些别的选项，具体可以查看他们的文档。</p>
<p>现在，开启一个容器，用watchtower来监控。</p>
<p><img src="/images/pasted-8.png" alt="upload successful"></p>
<p>watchtower会开始监控friendlyhello容器。接下来我把新镜像push到Docker Hub，watchtower接下来就会检测到有新镜像可用。它会关掉容器，然后用新镜像重启容器。这里会用到我们刚刚传到运行命令中的选项，换句话说，容器会在4000:80 公共端口选项上开启。</p>
<p>默认情况下，watchtower会轮询Dockder Hub注册表查找更新的镜像。你也可以通过在环境变量REPO_USER和REPO_PASS中添加指定注册表证书，来设置watchtower轮询私有注册表。</p>
<p>了解更多watchtower的用法，我推荐watchtower文档。</p>
<h3 id="docker-gc：收集垃圾容器和镜像"><a href="#docker-gc：收集垃圾容器和镜像" class="headerlink" title="docker-gc：收集垃圾容器和镜像"></a>docker-gc：收集垃圾容器和镜像</h3><p>docker-gc工具能够帮助Docker host清理不需要的容器和镜像。它可以删除存在一小时以上的容器。同时，它也可以删除没有容器的镜像。</p>
<p>docker-gc可以被当做脚本，也可以被视为容器。我们用容器方法运行docker-gc，用它来查找可以被删除的容器和镜像。</p>
<p><img src="/images/pasted-9.png" alt="upload successful"></p>
<p>在上述命令中，我们安装Docker socket文件，这样docker-gc就可以和Docker API进行交互。设置环境变量DRY_RUN=1，查找可被删除的容器和镜像。如果我们不这样设置，docker-gc直接删除它们。所以在删除之前，还是先确认一下。以上代码的输出结果如下：</p>
<p><img src="/images/pasted-10.png" alt="upload successful"></p>
<p>确认需要删除的容器和镜像之后，再次运行docker-gc来进行删除清理，这次就不用再设置DRY_RUN参数了。</p>
<p><img src="/images/pasted-11.png" alt="upload successful"></p>
<p>上述命令运行后的输出会告诉你哪些容器和镜像已经被docker-gc删除。</p>
<p>了解更多docker-gc支持的选项，我推荐阅读docker-gc documentation。</p>
<h3 id="docker-slim：给你的容器瘦身"><a href="#docker-slim：给你的容器瘦身" class="headerlink" title="docker-slim：给你的容器瘦身"></a>docker-slim：给你的容器瘦身</h3><p>如果你对Docker镜像的大小有过担忧，docker-slim绝对是一丸灵丹妙药。</p>
<p>docker-slim工具可以通过静态和动态分析，针对你的“胖镜像”创建对应的“瘦镜像”。在Github上下载二进制文件，即可使用docker-slim。该二进制文件在Linux和Mac可用。下载之后添加到路径PATH。</p>
<p>我创建了一个Docker镜像示例应用“friendlyhello”，Docker官方文档中有用到。这个镜像的大小如下图所示，194MB。</p>
<p><img src="/images/pasted-12.png" alt="upload successful"></p>
<p>这么简单的一个应用，我们就要下载194MB的数据。再来看看docker-slim究竟能让它“瘦”多少。</p>
<p><img src="/images/pasted-13.png" alt="upload successful"></p>
<p>docker-slim工具先是对“胖镜像”进行一系列的检测，最终创建了对应的“瘦镜像”。看一下“瘦镜像”的大小：</p>
<p><img src="/images/pasted-14.png" alt="upload successful"></p>
<p>正如上图所示，“瘦镜像”大小为24.9MB。开启容器，运行照旧。docker-slim对java、python、ruby、和Node.js应用都非常友好。</p>
<p>你自己也试一下吧，看看结果如何。以我个人的项目来说，我认为docker-slim在大部分情况下都能适用。阅读docker-slim文档了解更多。</p>
<h3 id="rocker：打破Dockerfile限制"><a href="#rocker：打破Dockerfile限制" class="headerlink" title="rocker：打破Dockerfile限制"></a>rocker：打破Dockerfile限制</h3><p>很多Docker用户都用Dockerfile来构建镜像。Dockerfile是定义命令的声明方式，通过在命令行调用这些命令，可以对镜像进行操作。</p>
<p>rocker给Dockerfile的指令集增加了新的指令。rocker是由Grammaryly创建的，原意是用来解决Dockerfile格式的问题。Grammaryly团队写过一篇博客解释当初的动机。我建议你也看一下这篇博客，可以更好的理解rocker。他们在博客中提出的两个关键问题是：</p>
<p>Docker镜像的大小<br>构建速度缓慢<br>博客还提到了rocker添加的一些新指令。查看rocker文档了解更多。</p>
<p>MOUNT用来分享volume，这样依赖管理工具就可以重用。<br>FROM指令在Dockerfile中也存在。rocker添加了不止一条FROM指令。这就意味着，一个Rockerfile可以通过创建多个镜像。首个指令集使用所有依赖来创建artifact，第二个指令集可以使用已有的artifact。这种做法极大的降低了镜像的大小。<br>TAG用来标记处于不同构建阶段的镜像。这样一来就不在需要手动标记镜像了。<br>PUSH用来把镜像push到registry。<br>ATTACH用来和中间步骤交互，在debug的时候非常有用。<br>安装rocker，对Mac用户来说，只要运行几条brew命令就行了：</p>
<p><img src="/images/pasted-15.png" alt="upload successful"></p>
<p>安装完成后，就可以使用rocker创建镜像。</p>
<p><img src="/images/pasted-16.png" alt="upload successful"></p>
<p>创建镜像并将其push到Docker Hub，可以用下面这条命令：</p>
<p><img src="/images/pasted-17.png" alt="upload successful"></p>
<p>rocker功能十分完备，了解更多，请参阅其文档。</p>
<h3 id="ctop：容器的顶层界面工具"><a href="#ctop：容器的顶层界面工具" class="headerlink" title="ctop：容器的顶层界面工具"></a>ctop：容器的顶层界面工具</h3><p>ctop是我最近才开始使用的工具，它可以为多个容器提供实时显示的数据视图。如果你是Mac用户，可以按下面的命令安装ctop。</p>
<p><img src="/images/pasted-18.png" alt="upload successful"></p>
<p>安装之后，只需配置DOCKER_HOST环境变量，即可使用ctop。</p>
<p>运行ctop命令，可以查看所有容器的状态。</p>
<p>运行</p>
<p>ctop-a命令，可以仅查看当前运行的容器。</p>
<p>ctop简单好用，查看机器上运行的容器非常方便。了解更多，请看ctop文档。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【摘要】网上有很多不错的Docker工具，大部分在github上都是开源的。最近两年，我一直在使用Docker，并将其应用到了一些开发项目上。如果你刚开始使用Docker，你会发现它能应用到的实例远远多于预想。Docker能为你做更多，不会让你失望的！&lt;/p&gt;
&lt;p&gt;Doc
    
    </summary>
    
      <category term="Collection" scheme="http://zhangfei.tk/categories/Collection/"/>
    
    
      <category term="Docker" scheme="http://zhangfei.tk/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker的Secrets管理</title>
    <link href="http://zhangfei.tk/2017/05/18/Docker%E7%9A%84Secrets%E7%AE%A1%E7%90%86/"/>
    <id>http://zhangfei.tk/2017/05/18/Docker的Secrets管理/</id>
    <published>2017-05-18T12:41:58.000Z</published>
    <updated>2017-07-05T14:45:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>我相信当我们意识到重要且敏感的访问信息已经暴露到公共网络上，并可能使您的微服务无条件被访问。随着我们依赖于的开发出来的服务化的量不断增加， 这时跟踪敏感细节的数量也有所增加。为了应对这个问题，在“secrets managemen”领域出现了工具。</p>
<p>在这篇文章中，我们将看Docker Secrets，要求在Docker 1.13及更高版本的新秘密管理功能。</p>
<p>从Docker的角度来看，该功能不需要太多的工作，但是您可能需要重构应用程序以利用它。我们将介绍如何做到这一点的想法，但不是详细的。</p>
<p>Docker的 Secrets只适用于Docker群集，主要是因为这是秘密管理最有意义的领域。毕竟，Swarm是针对多个Docker实例需要在他们之间共享访问细节的生产用途。如果要在独立容器中使用秘密管理，则需要运行</p>
<p>scale值设置为1 的容器。适用于Mac和Windows的Docker不支持多节点群集模式，但您可以使用它们使用Docker Machine创建多节点群集。</p>
<p>创建两个机器，然后创建一个两个节点，并从该组中的一个swarm环境中运行本文中的案例。</p>
<h3 id="获得Secrets"><a href="#获得Secrets" class="headerlink" title="获得Secrets"></a>获得Secrets</h3><p>当您从命令行创建Secrets时，您可以使用所有可用的工具来创建随机密码和管道输出。例如，为数据库用户创建一个随机密码：</p>
<p>opensslrand-base6420|dockersecretcreatemariadb_password-</p>
<p>这将返回一个秘密的ID。</p>
<p>您需要再次发出此命令以生成MariaDB root用户的密码。您将需要这样才能开始使用，但您不需要为每项服务。</p>
<p>opensslrand-base6420|dockersecretcreatemariadb_root_password-</p>
<p>如果你已经忘记了你创建的秘密， 可以用ls查看，也可以用以下命令查看docker secret ls</p>
<h3 id="替换secrets"><a href="#替换secrets" class="headerlink" title="替换secrets"></a>替换secrets</h3><p>为了保持秘密，良好的秘密，服务之间的通信发生在您定义的覆盖网络中。它们只能通过调用其ID来在该覆盖网络中使用。</p>
<p>dockernetworkcreate-doverlaymariadb_private</p>
<p>这也将返回该网络的ID。再次，你可以docker network ls查看相关网络</p>
<h3 id="创建服务"><a href="#创建服务" class="headerlink" title="创建服务"></a>创建服务</h3><p>这个例子将有一个Docker节点运行MariaDB，一个运行Python的节点。在最终的应用程序中，Python应用程序将读取和写入数据库。</p>
<p>首先，添加一个MariaDB服务。此服务使用您创建的网络进行通信，之前创建的秘密保存为两个文件：一个用于根密码，一个用于默认用户密码。然后将所需的所有变量作为环境变量传递给服务。</p>
<p>dockerservicecreate\ –namemariadb\ –replicas1\ –networkmariadb_private\ –mounttype=volume,source=mydata,destination=/var/lib/mariadb\ –secretsource=mariadb_root_password,target=mariadb_root_password\ –secretsource=mariadb_password,target=mariadb_password\ -eMARIADB_ROOT_PASSWORD_FILE=”/run/secrets/mariadb_root_password”\ -eMARIADB_PASSWORD_FILE=”/run/secrets/mariadb_password”\ -eMARIADB_USER=”python”\ -eMARIADB_DATABASE=”python”\</p>
<p>Python实例再次使用您创建的专用网络，并复制网络中可访问的秘密。一个更好的（生产就绪的）选项将是创建您的应用程序在管理程序中需要的数据库，而不会给应用程序访问根密码，但这仅仅是一个例子。</p>
<p>dockerservicecreate\ –namecspython\ –replicas1\ –networkmariadb_private\ –publish50000:5000\ –mounttype=volume,source=pydata,destination=/var/www/html\ –secretsource=mariadb_root_password,target=python_root_password,mode=0400\ –secretsource=mariadb_password,target=python_password,mode=0400\ -ePYTHON_DB_USER=”python”\ -ePYTHON_DB_ROOT_PASSWORD_FILE=”/run/secrets/python_root_password”\ -ePYTHON_DB_PASSWORD_FILE=”/run/secrets/python_password”\ -ePYTHON_DB_HOST=”mariadb:3306”\ -ePYTHON_DB_NAME=”python”\</p>
<p>上面的示例使用我创建的一个简单的Docker映像，它设置用于使用Flask创建Web应用程序的软件包，用于提供Web页面和PyMySQL来进行数据库访问。代码没有做太多，但显示了如何从Docker容器访问环境变量。</p>
<p>例如，要连接到没有指定数据库的数据库服务器：</p>
<p>importos importMySQLdb db=MySQLdb.connect(host=os.environ[‘PYTHON_DB_HOST’], user=os.environ[‘PYTHON_DB_ROOT_USER’], passwd=os.environ[‘PYTHON_DB_PASSWORD_FILE’]) cur=db.cursor() print(db) db.close()</p>
<p>更新secrets</p>
<p>频繁更改敏感信息是个好习惯。但是，您可能知道，在应用程序中更新这些细节是一个沉闷的过程，最不愿意避免。通过服务，Docker Secrets管理允许您更改值，而无需更改代码。</p>
<p>创建一个新秘密：</p>
<p>opensslrand-base6420|dockersecretcreatemariadb_password_march-</p>
<p>从MariaDB服务中删除当前密码的访问权限：</p>
<p>dockerserviceupdate\ –secret-rmmariadb_password\</p>
<p>并让它访问新的秘密，将目标指向新的值：</p>
<p>dockerserviceupdate\ –secret-addsource=mariadb_password_march,target=mysql_password\</p>
<p>更新Python服务：</p>
<p>dockerserviceupdate\ –secret-rmmariadb_password\ –secret-addsource=mariadb_password_march,target=python_password,mode=0400\</p>
<p>并删除旧秘密：</p>
<p>dockersecretrmmariadb_password</p>
<h3 id="扩展说明"><a href="#扩展说明" class="headerlink" title="扩展说明"></a>扩展说明</h3><p>Docker Secrets是一个新功能，但Docker鼓励镜像维护人员尽快为Docker用户提供更好的安全性。这需要允许与上述示例类似的过程，其中容器可以从通过生成秘密而不是硬编码到应用中创建的文件来读取其需要的每个参数。这可以强制实施集装箱应用程序，因为容器可以来回走动，但是始终可以访问您的应用程序运行所需的重要信息。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我相信当我们意识到重要且敏感的访问信息已经暴露到公共网络上，并可能使您的微服务无条件被访问。随着我们依赖于的开发出来的服务化的量不断增加， 这时跟踪敏感细节的数量也有所增加。为了应对这个问题，在“secrets managemen”领域出现了工具。&lt;/p&gt;
&lt;p&gt;在这篇文章
    
    </summary>
    
      <category term="Essay" scheme="http://zhangfei.tk/categories/Essay/"/>
    
    
      <category term="Docker" scheme="http://zhangfei.tk/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>四个Kubernetes集群管理工具</title>
    <link href="http://zhangfei.tk/2017/05/18/%E5%9B%9B%E4%B8%AAKubernetes%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    <id>http://zhangfei.tk/2017/05/18/四个Kubernetes集群管理工具/</id>
    <published>2017-05-18T12:33:40.000Z</published>
    <updated>2017-07-05T14:45:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>几乎所有用过Kubernetes的人都会发现其缺点，随着大K在负载平衡和工作管理方面的重大改进，用户可以将注意力逐渐转移到其他地方了，这里有四个项目可以减轻Kubernetes集群管理的负载。</p>
<p><img src="http://p1.pstatp.com/large/212f0004094fad2d1aa6" alt="Kubernetes"></p>
<h1 id="Kube-applier"><a href="#Kube-applier" class="headerlink" title="Kube-applier"></a>Kube-applier</h1><p>Kubernetes成功的关键是其与除Google以外的IT厂商和产品的接触。云存储公司Box收购了Kubernetes，并开放了一些用于帮助其内部部署的项目，kube-applier就是这样一个项目。</p>
<p>作为Kubernetes服务运行的Kube-applier，为Gube仓库中托管的Kubernetes集群提供了一组声明性配置文件，并将其持续应用于集群中的pod。无论何时对定义文件进行任何更改，它们都将被自动提取并应用于相关的pod。</p>
<p>更改也可以按计划或按需应用。Kube应用程序每次运行时都会记录其行为，并提供与Prometheus兼容的指标，以便用户及时了解影响集群的行为。</p>
<h1 id="Kubetop"><a href="#Kubetop" class="headerlink" title="Kubetop"></a>Kubetop</h1><p>有时最简单的工具反而是最有用的，比如Kubetop，它用Python编写，Kubetop会列出所有当前运行的节点，这些节点上所有的pod，这些pod中的所有容器，每个节点的CPU和内存利用率，类似于Unix/Linux top的命令。它不应该用来替代更精细的日志记录或报告工具，因为它产生的信息太简单了，但有时候简单会让阅读Kubernetes集群报告更节省时间。</p>
<p>如果您只需要快速了解哪些因素和命令行影响了集群，这是一个很方便的选项。Kubernetes的kubectl也有类似的功能，但是Kubetop的输出格式更加整齐。</p>
<h1 id="Kubectx-K8senv"><a href="#Kubectx-K8senv" class="headerlink" title="Kubectx/K8senv"></a>Kubectx/K8senv</h1><p>Kubernetes有一个“上下文”的概念，用于引用具有不同配置数据的离散集群。用kubectl命令行工具在上下文之间切换可能是冗长和笨拙的，所以第三方提出了在flash中切换上下文的方法。</p>
<p>一个简单的shell脚本，Kubectx可以为Kubernetes上下文分配短名称，并使用短名称在它们之间切换。将破折号（-）传递给kubectx，将被切换回以前的内容，而无需记住名称。该脚本还支持完成名称的选项卡，因此用户不必挖掘长名称并手动重新键入。</p>
<p>另外一个shell脚本K8senv要简单得多，但功能远远不够强大。例如，它不能在当前和最后一个上下文之间进行翻转。</p>
<h1 id="kubeadm-dind-cluster"><a href="#kubeadm-dind-cluster" class="headerlink" title="kubeadm-dind-cluster"></a>kubeadm-dind-cluster</h1><p>如果你想启动一个本地的单节点Kubernetes实例进行测试，那么Kubernetes提供了一个很好的默认组件：Minikube。但是对于那些想要测试和开发多节点集群Kubernetes的人还有一个选择：Mirantis的kubeadm-dind-cluster（KDC）。</p>
<p>KDC通过使用Kubernetes的kubeadm应用程序来启动由Docker容器而不是VM组成的集群。这可以让您在使用Kubernetes时更快地重新启动集群，因此可以更快速地查看任何代码更改造成的影响，也可以在持续集成环境中使用KDC，而不会遇到嵌套虚拟化问题。KDC运行跨平台的Linux，MacOS，Windows，并且不需要Go安装，因为它使用了Dockerized构建的Kubernetes。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;几乎所有用过Kubernetes的人都会发现其缺点，随着大K在负载平衡和工作管理方面的重大改进，用户可以将注意力逐渐转移到其他地方了，这里有四个项目可以减轻Kubernetes集群管理的负载。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p1.pstatp.com/la
    
    </summary>
    
      <category term="Essay" scheme="http://zhangfei.tk/categories/Essay/"/>
    
    
      <category term="Kubernetes" scheme="http://zhangfei.tk/tags/Kubernetes/"/>
    
      <category term="k8s" scheme="http://zhangfei.tk/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>Java 9 中的 9 个新特性</title>
    <link href="http://zhangfei.tk/2017/05/16/Java-9-%E4%B8%AD%E7%9A%84-9-%E4%B8%AA%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://zhangfei.tk/2017/05/16/Java-9-中的-9-个新特性/</id>
    <published>2017-05-16T14:52:00.000Z</published>
    <updated>2017-07-05T14:45:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-9-中的-9-个新特性"><a href="#Java-9-中的-9-个新特性" class="headerlink" title="Java 9 中的 9 个新特性"></a>Java 9 中的 9 个新特性</h1><p><img src="/images/pasted-0.png" alt="upload successful"></p>
<p>Java 8 发布三年多之后，即将快到2017年7月下一个版本发布的日期了。 你可能已经听说过 Java 9 的模块系统，但是这个新版本还有许多其它的更新。 这里有九个令人兴奋的新功能将与 Java 9 一起发布。</p>
<h2 id="Java-平台级模块系统"><a href="#Java-平台级模块系统" class="headerlink" title="Java 平台级模块系统"></a>Java 平台级模块系统</h2><p>Java 9 的定义功能是一套全新的模块系统。当代码库越来越大，创建复杂，盘根错节的“意大利面条式代码”的几率呈指数级的增长。这时候就得面对两个基础的问题: 很难真正地对代码进行封装, 而系统并没有对不同部分（也就是 JAR 文件）之间的依赖关系有个明确的概念。每一个公共类都可以被类路径之下任何其它的公共类所访问到, 这样就会导致无意中使用了并不想被公开访问的 API。此外，类路径本身也存在问题: 你怎么知晓所有需要的 JAR 都已经有了, 或者是不是会有重复的项呢? 模块系统把这俩个问题都给解决了。</p>
<p>模块化的 JAR 文件都包含一个额外的模块描述器。在这个模块描述器中, 对其它模块的依赖是通过 “requires” 来表示的。另外, “exports” 语句控制着哪些包是可以被其它模块访问到的。所有不被导出的包默认都封装在模块的里面。如下是一个模块描述器的示例，存在于 “module-info.java” 文件中:</p>
<p>module blog {<br>我们可以如下展示模块：</p>
<p><img src="/images/pasted-1.png" alt="upload successful"></p>
<p>请注意，两个模块都包含封装的包，因为它们没有被导出（使用橙色盾牌可视化）。 没有人会偶然地使用来自这些包中的类。Java 平台本身也使用自己的模块系统进行了模块化。通过封装 JDK 的内部类，平台更安全，持续改进也更容易。</p>
<p>当启动一个模块化应用时， JVM 会验证是否所有的模块都能使用，这基于 <code>requires</code> 语句——比脆弱的类路径迈进了一大步。模块允许你更好地强制结构化封装你的应用并明确依赖。你可以在这个课程中学习更多关于 Java 9 中模块工作的信息 。</p>
<h2 id="Linking"><a href="#Linking" class="headerlink" title="Linking"></a>Linking</h2><p>当你使用具有显式依赖关系的模块和模块化的 JDK 时，新的可能性出现了。你的应用程序模块现在将声明其对其他应用程序模块的依赖以及对其所使用的 JDK 模块的依赖。为什么不使用这些信息创建一个最小的运行时环境，其中只包含运行应用程序所需的那些模块呢？ 这可以通过 Java 9 中的新的 jlink 工具实现。你可以创建针对应用程序进行优化的最小运行时映像而不需要使用完全加载 JDK 安装版本。</p>
<h2 id="JShell-交互式-Java-REPL"><a href="#JShell-交互式-Java-REPL" class="headerlink" title="JShell: 交互式 Java REPL"></a>JShell: 交互式 Java REPL</h2><p>许多语言已经具有交互式编程环境，Java 现在加入了这个俱乐部。您可以从控制台启动 jshell ，并直接启动输入和执行 Java 代码。 jshell 的即时反馈使它成为探索 API 和尝试语言特性的好工具。</p>
<p><img src="/images/pasted-2.png" alt="upload successful"></p>
<p>测试一个 Java 正则表达式是一个很好的说明 jshell 如何使您的生活更轻松的例子。 交互式 shell 还可以提供良好的教学环境以及提高生产力，您可以在此了解更多信息。在教人们如何编写 Java 的过程中，不再需要解释 “public static void main（String [] args）” 这句废话。</p>
<h2 id="改进的-Javadoc"><a href="#改进的-Javadoc" class="headerlink" title="改进的 Javadoc"></a>改进的 Javadoc</h2><p>有时一些小事情可以带来很大的不同。你是否就像我一样在一直使用 Google 来查找正确的 Javadoc 页面呢？ 这不再需要了。Javadoc 现在支持在 API 文档中的进行搜索。另外，Javadoc 的输出现在符合兼容 HTML5 标准。此外，你会注意到，每个 Javadoc 页面都包含有关 JDK 模块类或接口来源的信息。</p>
<p><img src="/images/pasted-3.png" alt="upload successful"></p>
<h2 id="集合工厂方法"><a href="#集合工厂方法" class="headerlink" title="集合工厂方法"></a>集合工厂方法</h2><p>通常，您希望在代码中创建一个集合（例如，List 或 Set ），并直接用一些元素填充它。 实例化集合，几个 “add” 调用，使得代码重复。 Java 9，添加了几种集合工厂方法：</p>
<p>Set<integer> ints = Set.of(1, 2, 3);List<string> strings = List.of(“first”, “second”);<br>除了更短和更好阅读之外，这些方法也可以避免您选择特定的集合实现。 事实上，从工厂方法返回已放入数个元素的集合实现是高度优化的。这是可能的，因为它们是不可变的：在创建后，继续添加元素到这些集合会导致 “UnsupportedOperationException” 。</string></integer></p>
<h2 id="改进的-Stream-API"><a href="#改进的-Stream-API" class="headerlink" title="改进的 Stream API"></a>改进的 Stream API</h2><p>长期以来，Stream API 都是 Java 标准库最好的改进之一。通过这套 API 可以在集合上建立用于转换的申明管道。在 Java 9 中它会变得更好。Stream 接口中添加了 4 个新的方法：dropWhile, takeWhile, ofNullable。还有个 iterate 方法的新重载方法，可以让你提供一个 Predicate (判断条件)来指定什么时候结束迭代：</p>
<p>IntStream.iterate(1, i -&gt; i &lt; 100, i -&gt; i + 1).forEach(System.out::println);<br>第二个参数是一个 Lambda，它会在当前 IntStream 中的元素到达 100 的时候返回 true。因此这个简单的示例是向控制台打印 1 到 99。</p>
<p>除了对 Stream 本身的扩展，Optional 和 Stream 之间的结合也得到了改进。现在可以通过 Optional 的新方法 <code>stram</code> 将一个 Optional 对象转换为一个(可能是空的) Stream 对象：</p>
<p>Stream<integer> s = Optional.of(1).stream();<br>在组合复杂的 Stream 管道时，将 Optional 转换为 Stream 非常有用。</integer></p>
<h2 id="私有接口方法"><a href="#私有接口方法" class="headerlink" title="私有接口方法"></a>私有接口方法</h2><p>Java 8 为我们带来了接口的默认方法。 接口现在也可以包含行为，而不仅仅是方法签名。 但是，如果在接口上有几个默认方法，代码几乎相同，会发生什么情况？ 通常，您将重构这些方法，调用一个可复用的私有方法。 但默认方法不能是私有的。 将复用代码创建为一个默认方法不是一个解决方案，因为该辅助方法会成为公共API的一部分。 使用 Java 9，您可以向接口添加私有辅助方法来解决此问题：</p>
<p>public interface MyInterface {<br>如果您使用默认方法开发 API ，那么私有接口方法可能有助于构建其实现。</p>
<h2 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h2><p>Java 9 中有新的方式来处理 HTTP 调用。这个迟到的特性用于代替老旧的 <code>HttpURLConnection</code> API，并提供对 WebSocket 和 HTTP/2 的支持。注意：新的 HttpClient API 在 Java 9 中以所谓的孵化器模块交付。也就是说，这套 API 不能保证 100% 完成。不过你可以在 Java 9 中开始使用这套 API：</p>
<p>HttpClient client = HttpClient.newHttpClient();HttpRequest req =<br>除了这个简单的请求/响应模型之外，HttpClient 还提供了新的 API 来处理 HTTP/2 的特性，比如流和服务端推送。</p>
<h2 id="多版本兼容-JAR"><a href="#多版本兼容-JAR" class="headerlink" title="多版本兼容 JAR"></a>多版本兼容 JAR</h2><p>我们最后要来着重介绍的这个特性对于库的维护者而言是个特别好的消息。当一个新版本的 Java 出现的时候，你的库用户要花费数年时间才会切换到这个新的版本。这就意味着库得去向后兼容你想要支持的最老的 Java 版本 (许多情况下就是 Java 6 或者 7)。这实际上意味着未来的很长一段时间，你都不能在库中运用 Java 9 所提供的新特性。幸运的是，多版本兼容 JAR 功能能让你创建仅在特定版本的 Java 环境中运行库程序时选择使用的 class 版本：</p>
<p>multirelease.jar<br>在上述场景中， multirelease.jar 可以在 Java 9 中使用, 不过 Helper 这个类使用的不是顶层的multirelease.Helper 这个 class, 而是处在“META-INF/versions/9”下面的这个。这是特别为 Java 9 准备的 class 版本，可以运用 Java 9 所提供的特性和库。同时，在早期的 Java 诸版本中使用这个 JAR 也是能运行的，因为较老版本的 Java 只会看到顶层的这个 Helper 类。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-9-中的-9-个新特性&quot;&gt;&lt;a href=&quot;#Java-9-中的-9-个新特性&quot; class=&quot;headerlink&quot; title=&quot;Java 9 中的 9 个新特性&quot;&gt;&lt;/a&gt;Java 9 中的 9 个新特性&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/ima
    
    </summary>
    
      <category term="Essay" scheme="http://zhangfei.tk/categories/Essay/"/>
    
    
      <category term="Java" scheme="http://zhangfei.tk/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java开源项目</title>
    <link href="http://zhangfei.tk/2017/05/04/java%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    <id>http://zhangfei.tk/2017/05/04/java开源项目/</id>
    <published>2017-05-04T15:53:43.000Z</published>
    <updated>2017-07-05T14:45:54.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文地址：<a href="http://blog.longjiazuo.com/archives/2625" target="_blank" rel="external">http://blog.longjiazuo.com/archives/2625</a></p>
</blockquote>
<h1 id="开源相关的文章链接："><a href="#开源相关的文章链接：" class="headerlink" title="开源相关的文章链接："></a>开源相关的文章链接：</h1><h2 id="Apache的开源软件列表"><a href="#Apache的开源软件列表" class="headerlink" title="Apache的开源软件列表"></a>Apache的开源软件列表</h2><blockquote>
<p><a href="http://www.oschina.net/project/apache" target="_blank" rel="external">http://www.oschina.net/project/apache</a></p>
</blockquote>
<h2 id="Java开源Apache项目"><a href="#Java开源Apache项目" class="headerlink" title="Java开源Apache项目"></a>Java开源Apache项目</h2><blockquote>
<p><a href="http://www.open-open.com/56.htm" target="_blank" rel="external">http://www.open-open.com/56.htm</a></p>
</blockquote>
<h2 id="阿里巴巴的开源软件列表"><a href="#阿里巴巴的开源软件列表" class="headerlink" title="阿里巴巴的开源软件列表"></a>阿里巴巴的开源软件列表</h2><blockquote>
<p><a href="http://www.oschina.net/project/alibaba" target="_blank" rel="external">http://www.oschina.net/project/alibaba</a></p>
</blockquote>
<h2 id="百度的开源软件列表"><a href="#百度的开源软件列表" class="headerlink" title="百度的开源软件列表"></a>百度的开源软件列表</h2><blockquote>
<p><a href="http://www.oschina.net/project/baidu" target="_blank" rel="external">http://www.oschina.net/project/baidu</a></p>
</blockquote>
<h2 id="腾讯的开源软件列表"><a href="#腾讯的开源软件列表" class="headerlink" title="腾讯的开源软件列表"></a>腾讯的开源软件列表</h2><blockquote>
<p><a href="http://www.oschina.net/project/tencent" target="_blank" rel="external">http://www.oschina.net/project/tencent</a></p>
</blockquote>
<h2 id="华为的开源软件列表"><a href="#华为的开源软件列表" class="headerlink" title="华为的开源软件列表"></a>华为的开源软件列表</h2><blockquote>
<p><a href="http://www.oschina.net/project/huawei" target="_blank" rel="external">http://www.oschina.net/project/huawei</a></p>
</blockquote>
<h2 id="Netflix的开源软件列表"><a href="#Netflix的开源软件列表" class="headerlink" title="Netflix的开源软件列表"></a>Netflix的开源软件列表</h2><blockquote>
<p><a href="http://www.oschina.net/project/netflix" target="_blank" rel="external">http://www.oschina.net/project/netflix</a></p>
</blockquote>
<h2 id="大公司都有哪些开源项目"><a href="#大公司都有哪些开源项目" class="headerlink" title="大公司都有哪些开源项目"></a>大公司都有哪些开源项目</h2><blockquote>
<p><a href="http://www.cnblogs.com/dunitian/p/5581520.html" target="_blank" rel="external">http://www.cnblogs.com/dunitian/p/5581520.html</a></p>
</blockquote>
<h2 id="2017年你不能错过的Java类库"><a href="#2017年你不能错过的Java类库" class="headerlink" title="2017年你不能错过的Java类库"></a>2017年你不能错过的Java类库</h2><blockquote>
<p><a href="http://www.importnew.com/23858.html" target="_blank" rel="external">http://www.importnew.com/23858.html</a></p>
</blockquote>
<h2 id="公司开源导航页"><a href="#公司开源导航页" class="headerlink" title="公司开源导航页"></a>公司开源导航页</h2><blockquote>
<p><a href="https://www.oschina.net/company" target="_blank" rel="external">https://www.oschina.net/company</a></p>
</blockquote>
<h1 id="开源项目链接地址："><a href="#开源项目链接地址：" class="headerlink" title="开源项目链接地址："></a>开源项目链接地址：</h1><h2 id="【spring项目】"><a href="#【spring项目】" class="headerlink" title="【spring项目】"></a>【spring项目】</h2><h3 id="spring以及子项目"><a href="#spring以及子项目" class="headerlink" title="spring以及子项目:"></a>spring以及子项目:</h3><blockquote>
<p>github地址:<a href="https://github.com/spring-projects" target="_blank" rel="external">https://github.com/spring-projects</a></p>
</blockquote>
<h2 id="【spring-cloud项目】"><a href="#【spring-cloud项目】" class="headerlink" title="【spring cloud项目】"></a>【spring cloud项目】</h2><h3 id="spring-cloud系列项目"><a href="#spring-cloud系列项目" class="headerlink" title="spring cloud系列项目:"></a>spring cloud系列项目:</h3><blockquote>
<p>github地址:<a href="https://github.com/spring-cloud" target="_blank" rel="external">https://github.com/spring-cloud</a></p>
</blockquote>
<h2 id="【apache基金会】"><a href="#【apache基金会】" class="headerlink" title="【apache基金会】"></a>【apache基金会】</h2><h3 id="apache开源项目列表"><a href="#apache开源项目列表" class="headerlink" title="apache开源项目列表:"></a>apache开源项目列表:</h3><blockquote>
<p>apache地址:<a href="http://www.apache.org/index.html#projects-list" target="_blank" rel="external">http://www.apache.org/index.html#projects-list</a></p>
</blockquote>
<h3 id="apache项目github地址"><a href="#apache项目github地址" class="headerlink" title="apache项目github地址:"></a>apache项目github地址:</h3><blockquote>
<p>github地址:<a href="https://github.com/apache" target="_blank" rel="external">https://github.com/apache</a></p>
</blockquote>
<h2 id="【eclipse基金会】"><a href="#【eclipse基金会】" class="headerlink" title="【eclipse基金会】"></a>【eclipse基金会】</h2><h3 id="轻量级的高性能JVM应用平台Vert-x"><a href="#轻量级的高性能JVM应用平台Vert-x" class="headerlink" title="轻量级的高性能JVM应用平台Vert.x"></a>轻量级的高性能JVM应用平台Vert.x</h3><blockquote>
<p>apache地址:<a href="https://github.com/eclipse/vert.x" target="_blank" rel="external">https://github.com/eclipse/vert.x</a><br>官方参考文档：<a href="http://vertx.io/docs/" target="_blank" rel="external">http://vertx.io/docs/</a></p>
</blockquote>
<h2 id="【阿里巴巴】"><a href="#【阿里巴巴】" class="headerlink" title="【阿里巴巴】"></a>【阿里巴巴】</h2><h3 id="开源JSON处理框架fastjson"><a href="#开源JSON处理框架fastjson" class="headerlink" title="开源JSON处理框架fastjson:"></a>开源JSON处理框架fastjson:</h3><blockquote>
<p>github地址:<a href="https://github.com/alibaba/fastjson" target="_blank" rel="external">https://github.com/alibaba/fastjson</a></p>
</blockquote>
<h3 id="开源数据库连接池druid："><a href="#开源数据库连接池druid：" class="headerlink" title="开源数据库连接池druid："></a>开源数据库连接池druid：</h3><blockquote>
<p>github地址:<a href="https://github.com/alibaba/druid" target="_blank" rel="external">https://github.com/alibaba/druid</a></p>
</blockquote>
<h3 id="开源分布式服务框架dubbo："><a href="#开源分布式服务框架dubbo：" class="headerlink" title="开源分布式服务框架dubbo："></a>开源分布式服务框架dubbo：</h3><blockquote>
<p>github地址:<a href="https://github.com/alibaba/dubbo" target="_blank" rel="external">https://github.com/alibaba/dubbo</a></p>
</blockquote>
<h3 id="开源分布式开放消息队列RocketMQ："><a href="#开源分布式开放消息队列RocketMQ：" class="headerlink" title="开源分布式开放消息队列RocketMQ："></a>开源分布式开放消息队列RocketMQ：</h3><blockquote>
<p>github地址:<a href="https://github.com/alibaba/RocketMQ" target="_blank" rel="external">https://github.com/alibaba/RocketMQ</a><br>备注：RocketMQ已经进入apache孵化器,在孵化器的github地址如下：<br>github地址:<a href="https://github.com/apache/incubator-rocketmq" target="_blank" rel="external">https://github.com/apache/incubator-rocketmq</a></p>
</blockquote>
<h3 id="开源实时流式计算框架jstorm"><a href="#开源实时流式计算框架jstorm" class="headerlink" title="开源实时流式计算框架jstorm"></a>开源实时流式计算框架jstorm</h3><blockquote>
<p>github地址:<a href="https://github.com/alibaba/jstorm" target="_blank" rel="external">https://github.com/alibaba/jstorm</a></p>
</blockquote>
<h3 id="开源分布式数据库同步系统otter"><a href="#开源分布式数据库同步系统otter" class="headerlink" title="开源分布式数据库同步系统otter"></a>开源分布式数据库同步系统otter</h3><blockquote>
<p>github地址:<a href="https://github.com/alibaba/otter" target="_blank" rel="external">https://github.com/alibaba/otter</a></p>
</blockquote>
<h3 id="开源分布式数据库服务中间件cobar"><a href="#开源分布式数据库服务中间件cobar" class="headerlink" title="开源分布式数据库服务中间件cobar"></a>开源分布式数据库服务中间件cobar</h3><blockquote>
<p>github地址:<a href="https://github.com/alibaba/cobar" target="_blank" rel="external">https://github.com/alibaba/cobar</a></p>
</blockquote>
<h2 id="【唯品会】"><a href="#【唯品会】" class="headerlink" title="【唯品会】"></a>【唯品会】</h2><h3 id="开源调度框架Saturn"><a href="#开源调度框架Saturn" class="headerlink" title="开源调度框架Saturn:"></a>开源调度框架Saturn:</h3><blockquote>
<p>github地址:<a href="https://github.com/vipshop/Saturn" target="_blank" rel="external">https://github.com/vipshop/Saturn</a></p>
</blockquote>
<h2 id="【当当】"><a href="#【当当】" class="headerlink" title="【当当】"></a>【当当】</h2><h3 id="开源调度框架elastic-job"><a href="#开源调度框架elastic-job" class="headerlink" title="开源调度框架elastic-job:"></a>开源调度框架elastic-job:</h3><blockquote>
<p>github地址:<a href="https://github.com/dangdangdotcom/elastic-job" target="_blank" rel="external">https://github.com/dangdangdotcom/elastic-job</a></p>
</blockquote>
<h3 id="开源分库分表中间件Sharding-JDBC"><a href="#开源分库分表中间件Sharding-JDBC" class="headerlink" title="开源分库分表中间件Sharding-JDBC:"></a>开源分库分表中间件Sharding-JDBC:</h3><blockquote>
<p>github地址:<a href="https://github.com/dangdangdotcom/sharding-jdbc" target="_blank" rel="external">https://github.com/dangdangdotcom/sharding-jdbc</a></p>
</blockquote>
<h3 id="开源分布式服务框架dubbox"><a href="#开源分布式服务框架dubbox" class="headerlink" title="开源分布式服务框架dubbox:"></a>开源分布式服务框架dubbox:</h3><blockquote>
<p>github地址:<a href="https://github.com/dangdangdotcom/dubbox" target="_blank" rel="external">https://github.com/dangdangdotcom/dubbox</a></p>
</blockquote>
<h2 id="【百度】"><a href="#【百度】" class="headerlink" title="【百度】"></a>【百度】</h2><h3 id="分布式系统配置管理disconf"><a href="#分布式系统配置管理disconf" class="headerlink" title="分布式系统配置管理disconf"></a>分布式系统配置管理disconf</h3><blockquote>
<p>github地址:<a href="https://github.com/knightliao/disconf" target="_blank" rel="external">https://github.com/knightliao/disconf</a></p>
</blockquote>
<h2 id="【腾讯】"><a href="#【腾讯】" class="headerlink" title="【腾讯】"></a>【腾讯】</h2><h3 id="开源基于微服务的平台Tars"><a href="#开源基于微服务的平台Tars" class="headerlink" title="开源基于微服务的平台Tars"></a>开源基于微服务的平台Tars</h3><blockquote>
<p>github地址:<a href="https://github.com/Tencent/Tars" target="_blank" rel="external">https://github.com/Tencent/Tars</a></p>
</blockquote>
<h2 id="【携程】"><a href="#【携程】" class="headerlink" title="【携程】"></a>【携程】</h2><h3 id="开源Redis多数据中心复制管理系统x-pipe"><a href="#开源Redis多数据中心复制管理系统x-pipe" class="headerlink" title="开源Redis多数据中心复制管理系统x-pipe"></a>开源Redis多数据中心复制管理系统x-pipe</h3><blockquote>
<p>github地址:<a href="https://github.com/ctripcorp/x-pipe" target="_blank" rel="external">https://github.com/ctripcorp/x-pipe</a></p>
</blockquote>
<h3 id="开源配置管理平台apollo"><a href="#开源配置管理平台apollo" class="headerlink" title="开源配置管理平台apollo"></a>开源配置管理平台apollo</h3><blockquote>
<p>github地址:<a href="https://github.com/ctripcorp/apollo" target="_blank" rel="external">https://github.com/ctripcorp/apollo</a></p>
</blockquote>
<h3 id="开源数据库访问框架dal"><a href="#开源数据库访问框架dal" class="headerlink" title="开源数据库访问框架dal"></a>开源数据库访问框架dal</h3><blockquote>
<p>github地址:<a href="https://github.com/ctripcorp/dal" target="_blank" rel="external">https://github.com/ctripcorp/dal</a></p>
</blockquote>
<h2 id="【大众点评】"><a href="#【大众点评】" class="headerlink" title="【大众点评】"></a>【大众点评】</h2><h3 id="开源实时应用监控平台cat"><a href="#开源实时应用监控平台cat" class="headerlink" title="开源实时应用监控平台cat"></a>开源实时应用监控平台cat</h3><blockquote>
<p>github地址:<a href="https://github.com/dianping/cat" target="_blank" rel="external">https://github.com/dianping/cat</a></p>
</blockquote>
<h2 id="【谷歌Google】"><a href="#【谷歌Google】" class="headerlink" title="【谷歌Google】"></a>【谷歌Google】</h2><h3 id="开源java轻量级IOC框架Guice"><a href="#开源java轻量级IOC框架Guice" class="headerlink" title="开源java轻量级IOC框架Guice"></a>开源java轻量级IOC框架Guice</h3><blockquote>
<p>github地址:<a href="https://github.com/google/guice" target="_blank" rel="external">https://github.com/google/guice</a></p>
</blockquote>
<h3 id="开源基于java1-6的类库集合的扩展guava"><a href="#开源基于java1-6的类库集合的扩展guava" class="headerlink" title="开源基于java1.6的类库集合的扩展guava"></a>开源基于java1.6的类库集合的扩展guava</h3><blockquote>
<p>github地址:<a href="https://github.com/google/guava" target="_blank" rel="external">https://github.com/google/guava</a></p>
</blockquote>
<h2 id="【移动支付公司Square】"><a href="#【移动支付公司Square】" class="headerlink" title="【移动支付公司Square】"></a>【移动支付公司Square】</h2><h3 id="开源处理网络请求的网络框架OkHttp"><a href="#开源处理网络请求的网络框架OkHttp" class="headerlink" title="开源处理网络请求的网络框架OkHttp"></a>开源处理网络请求的网络框架OkHttp</h3><blockquote>
<p>github地址:<a href="https://github.com/square/okhttp" target="_blank" rel="external">https://github.com/square/okhttp</a></p>
</blockquote>
<h3 id="网络请求框架Retrofit"><a href="#网络请求框架Retrofit" class="headerlink" title="网络请求框架Retrofit"></a>网络请求框架Retrofit</h3><blockquote>
<p>github地址:<a href="https://github.com/square/retrofit" target="_blank" rel="external">https://github.com/square/retrofit</a></p>
</blockquote>
<h2 id="【mybatis项目】"><a href="#【mybatis项目】" class="headerlink" title="【mybatis项目】"></a>【mybatis项目】</h2><h3 id="Sql映射持久层框架mybatis"><a href="#Sql映射持久层框架mybatis" class="headerlink" title="Sql映射持久层框架mybatis"></a>Sql映射持久层框架mybatis</h3><blockquote>
<p>github地址:<a href="https://github.com/mybatis/mybatis-3" target="_blank" rel="external">https://github.com/mybatis/mybatis-3</a></p>
</blockquote>
<h2 id="【hibernate项目】"><a href="#【hibernate项目】" class="headerlink" title="【hibernate项目】"></a>【hibernate项目】</h2><h3 id="对象关系映射框架hibernate"><a href="#对象关系映射框架hibernate" class="headerlink" title="对象关系映射框架hibernate"></a>对象关系映射框架hibernate</h3><blockquote>
<p>github地址:<a href="https://github.com/hibernate/hibernate-orm" target="_blank" rel="external">https://github.com/hibernate/hibernate-orm</a></p>
</blockquote>
<h2 id="开源组织或者个人项目"><a href="#开源组织或者个人项目" class="headerlink" title="开源组织或者个人项目"></a>开源组织或者个人项目</h2><p>说明：由于一些项目的名字比较类似,为了区分把作者加上,作者署名团队或者主要开发者。</p>
<h3 id="spring-boot中文参考文档"><a href="#spring-boot中文参考文档" class="headerlink" title="spring boot中文参考文档"></a>spring boot中文参考文档</h3><p>作者：qibaoguang</p>
<blockquote>
<p>github地址:<a href="https://github.com/qibaoguang/Spring-Boot-Reference-Guide" target="_blank" rel="external">https://github.com/qibaoguang/Spring-Boot-Reference-Guide</a></p>
</blockquote>
<h3 id="spring4中文参考文档"><a href="#spring4中文参考文档" class="headerlink" title="spring4中文参考文档"></a>spring4中文参考文档</h3><p>作者：Way Lau</p>
<blockquote>
<p>github地址:<a href="https://github.com/waylau/spring-framework-4-reference" target="_blank" rel="external">https://github.com/waylau/spring-framework-4-reference</a></p>
</blockquote>
<h3 id="开源分布式数据库中间件Mycat-Server"><a href="#开源分布式数据库中间件Mycat-Server" class="headerlink" title="开源分布式数据库中间件Mycat-Server"></a>开源分布式数据库中间件Mycat-Server</h3><p>作者：mycat开源团队</p>
<blockquote>
<p>github地址:<a href="https://github.com/MyCATApache/Mycat-Server" target="_blank" rel="external">https://github.com/MyCATApache/Mycat-Server</a></p>
</blockquote>
<h3 id="开源分布式数据库中间件mycat文档mycat-doc"><a href="#开源分布式数据库中间件mycat文档mycat-doc" class="headerlink" title="开源分布式数据库中间件mycat文档mycat-doc"></a>开源分布式数据库中间件mycat文档mycat-doc</h3><p>作者：mycat开源团队</p>
<blockquote>
<p>github地址:<a href="https://github.com/MyCATApache/Mycat-doc" target="_blank" rel="external">https://github.com/MyCATApache/Mycat-doc</a></p>
</blockquote>
<h3 id="基于spring的基础框架库springside"><a href="#基于spring的基础框架库springside" class="headerlink" title="基于spring的基础框架库springside"></a>基于spring的基础框架库springside</h3><p>作者：江南白衣</p>
<blockquote>
<p>github地址:<a href="https://github.com/springside/springside4" target="_blank" rel="external">https://github.com/springside/springside4</a></p>
</blockquote>
<h3 id="开源信息化快速开发平台jeesite"><a href="#开源信息化快速开发平台jeesite" class="headerlink" title="开源信息化快速开发平台jeesite"></a>开源信息化快速开发平台jeesite</h3><p>作者：thinkgem</p>
<blockquote>
<p>github地址:<a href="https://github.com/thinkgem/jeesite" target="_blank" rel="external">https://github.com/thinkgem/jeesite</a></p>
</blockquote>
<h3 id="Java资源大全中文版awesome-java-cn"><a href="#Java资源大全中文版awesome-java-cn" class="headerlink" title="Java资源大全中文版awesome-java-cn"></a>Java资源大全中文版awesome-java-cn</h3><p>作者：伯乐在线</p>
<blockquote>
<p>github地址:<a href="https://github.com/jobbole/awesome-java-cn" target="_blank" rel="external">https://github.com/jobbole/awesome-java-cn</a></p>
</blockquote>
<h3 id="通用权限管理系统cl-privilege"><a href="#通用权限管理系统cl-privilege" class="headerlink" title="通用权限管理系统cl-privilege"></a>通用权限管理系统cl-privilege</h3><p>作者：pumadong</p>
<blockquote>
<p>github地址:<a href="https://github.com/pumadong/cl-privilege" target="_blank" rel="external">https://github.com/pumadong/cl-privilege</a></p>
</blockquote>
<h3 id="开源分布式应用追踪分析系统sky-walking"><a href="#开源分布式应用追踪分析系统sky-walking" class="headerlink" title="开源分布式应用追踪分析系统sky-walking"></a>开源分布式应用追踪分析系统sky-walking</h3><p>作者：sky-walking团队</p>
<blockquote>
<p>github地址:<a href="https://github.com/wu-sheng/sky-walking" target="_blank" rel="external">https://github.com/wu-sheng/sky-walking</a></p>
</blockquote>
<h3 id="轻量级Java-Web框架smart-framework"><a href="#轻量级Java-Web框架smart-framework" class="headerlink" title="轻量级Java Web框架smart-framework"></a>轻量级Java Web框架smart-framework</h3><p>作者：黄勇</p>
<blockquote>
<p>git.oschina地址:<a href="http://git.oschina.net/huangyong/smart-framework" target="_blank" rel="external">http://git.oschina.net/huangyong/smart-framework</a></p>
</blockquote>
<h3 id="许雪里github"><a href="#许雪里github" class="headerlink" title="许雪里github:"></a>许雪里github:</h3><p>作者：许雪里</p>
<blockquote>
<p>github地址:<a href="https://github.com/xuxueli" target="_blank" rel="external">https://github.com/xuxueli</a></p>
</blockquote>
<h3 id="响应式函数编程框架RxJava"><a href="#响应式函数编程框架RxJava" class="headerlink" title="响应式函数编程框架RxJava"></a>响应式函数编程框架RxJava</h3><p>作者：ReactiveX</p>
<blockquote>
<p>github地址:<a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="external">https://github.com/ReactiveX/RxJava</a></p>
</blockquote>
<h3 id="常用的java基础工具类iceroot"><a href="#常用的java基础工具类iceroot" class="headerlink" title="常用的java基础工具类iceroot"></a>常用的java基础工具类iceroot</h3><p>作者：iceroot</p>
<blockquote>
<p>github地址:<a href="https://github.com/iceroot/iceroot" target="_blank" rel="external">https://github.com/iceroot/iceroot</a></p>
</blockquote>
<h3 id="开源轻量级的-高性能的事件总线MBassador"><a href="#开源轻量级的-高性能的事件总线MBassador" class="headerlink" title="开源轻量级的,高性能的事件总线MBassador"></a>开源轻量级的,高性能的事件总线MBassador</h3><p>作者：Benjamin Diedrichsen</p>
<blockquote>
<p>github地址:<a href="https://github.com/bennidi/mbassador" target="_blank" rel="external">https://github.com/bennidi/mbassador</a></p>
</blockquote>
<h3 id="通过注解来减少Java中的重复代码工具lombok"><a href="#通过注解来减少Java中的重复代码工具lombok" class="headerlink" title="通过注解来减少Java中的重复代码工具lombok"></a>通过注解来减少Java中的重复代码工具lombok</h3><p>作者：Reinier Zwitserloot</p>
<blockquote>
<p>github地址:<a href="https://github.com/rzwitserloot/lombok" target="_blank" rel="external">https://github.com/rzwitserloot/lombok</a></p>
</blockquote>
<h3 id="简单日志门面slf4j"><a href="#简单日志门面slf4j" class="headerlink" title="简单日志门面slf4j"></a>简单日志门面slf4j</h3><p>作者：QOS.ch</p>
<blockquote>
<p>github地址:<a href="https://github.com/qos-ch/slf4j" target="_blank" rel="external">https://github.com/qos-ch/slf4j</a></p>
</blockquote>
<h3 id="模拟测试框架Mockito"><a href="#模拟测试框架Mockito" class="headerlink" title="模拟测试框架Mockito"></a>模拟测试框架Mockito</h3><p>作者：mockito</p>
<blockquote>
<p>github地址:<a href="https://github.com/mockito/mockito" target="_blank" rel="external">https://github.com/mockito/mockito</a></p>
</blockquote>
<h3 id="结合JUnit、-Guice、-Mockito的高效组合测试框架Jukito"><a href="#结合JUnit、-Guice、-Mockito的高效组合测试框架Jukito" class="headerlink" title="结合JUnit、 Guice、 Mockito的高效组合测试框架Jukito"></a>结合JUnit、 Guice、 Mockito的高效组合测试框架Jukito</h3><p>作者：Arcbees</p>
<blockquote>
<p>github地址:<a href="https://github.com/ArcBees/Jukito" target="_blank" rel="external">https://github.com/ArcBees/Jukito</a></p>
</blockquote>
<h3 id="轻量化的分布式服务框架rsf"><a href="#轻量化的分布式服务框架rsf" class="headerlink" title="轻量化的分布式服务框架rsf"></a>轻量化的分布式服务框架rsf</h3><p>作者：Hasor Group</p>
<blockquote>
<p>码云地址:<a href="http://git.oschina.net/zycgit/rs" target="_blank" rel="external">http://git.oschina.net/zycgit/rs</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;http://blog.longjiazuo.com/archives/2625&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.longjiazuo.com/archives/2
    
    </summary>
    
      <category term="Collection" scheme="http://zhangfei.tk/categories/Collection/"/>
    
    
      <category term="Java" scheme="http://zhangfei.tk/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>怎样在复杂代码中找bug？</title>
    <link href="http://zhangfei.tk/2017/04/20/%E6%80%8E%E6%A0%B7%E5%9C%A8%E5%A4%8D%E6%9D%82%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%89%BEbug%EF%BC%9F/"/>
    <id>http://zhangfei.tk/2017/04/20/怎样在复杂代码中找bug？/</id>
    <published>2017-04-20T14:32:00.000Z</published>
    <updated>2017-07-05T14:45:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="避免错误"><a href="#避免错误" class="headerlink" title="避免错误"></a>避免错误</h1><h2 id="1、缺少必要的注释"><a href="#1、缺少必要的注释" class="headerlink" title="1、缺少必要的注释"></a>1、缺少必要的注释</h2><p>大段的if-else缺少注释，让维护者无法快速分辨分支逻辑。特定地方存在hack或复杂逻辑的代码，缺少注释会让后来者不明所以。为了你好，也为了后来者好，请务必加上代码。说不准以后还是由你来维护这段代码。</p>
<h2 id="2、不变和变化的部分拆分"><a href="#2、不变和变化的部分拆分" class="headerlink" title="2、不变和变化的部分拆分"></a>2、不变和变化的部分拆分</h2><p>程序员中流传着一句话，此处不要写死，将来必改。有经验的程序员会将一些业务层的逻辑抽象出来，写成配置文件，好处就是若后续需求有改变，只需改配置文件即可，肯定不会引入bug。</p>
<h2 id="3、忽视测试部分"><a href="#3、忽视测试部分" class="headerlink" title="3、忽视测试部分"></a>3、忽视测试部分</h2><p>程序员中又流传着一句话，没有测试的代码等于没写。虽不敢全部赞同，却也有几分道理。从测试用例驱动开发，持续集成，每次编译自动跑测试用例，能够保证系统的稳定同时也减轻测试成本。自己改的的部分做好自测，理解需求，做一个有责任心的工程师。</p>
<h2 id="4、直接操作数据"><a href="#4、直接操作数据" class="headerlink" title="4、直接操作数据"></a>4、直接操作数据</h2><p>你应该通过方法去操作数据，而不是直接操作数据,这样能够保证你总能操作数据正确。例如一个类中定义的属性发生变化了，代码中所有涉及到直接操作该属性的代码都需要修改。如果通过方法操作该属性，则仅需修改操作方法，对于外部调用者，类属性变化被屏蔽了，遵循了解耦的原则，代码稳定性大大提高。</p>
<h2 id="5、缺乏文档或文档质量低下"><a href="#5、缺乏文档或文档质量低下" class="headerlink" title="5、缺乏文档或文档质量低下"></a>5、缺乏文档或文档质量低下</h2><p>前期文档很重要，不论是框架的API使用手册，还是需求或设计文档，以及各种既定流程的规范，不同种类的模板及核对表，等等这些文档，对于项目来说都是非常重要的资源。而往往有些项目，这类文档就是交由非软件行业的人员来编写，或者前期根本不打算在文档上浪费时间。</p>
<h2 id="6、无尽的需求变更，永远追不上的进度"><a href="#6、无尽的需求变更，永远追不上的进度" class="headerlink" title="6、无尽的需求变更，永远追不上的进度"></a>6、无尽的需求变更，永远追不上的进度</h2><p>这是最常见也是最可怕的，因为无论怎样，我们都无法完成它。客户可能认为改个程序，就像改个Excel一样简单省事，甚至会使用可动用的一切权利和资源来推行变更。好吧，我承认这样的客户我遇到过很多。当我向客户解释过变更的代价并提供备选方案后，也就只能等待客户的选择了，这多少有些运数的成分，但也是无奈之举。</p>
<h2 id="7、仅仅靠加班应对进度落后"><a href="#7、仅仅靠加班应对进度落后" class="headerlink" title="7、仅仅靠加班应对进度落后"></a>7、仅仅靠加班应对进度落后</h2><p>进度落后并不可怕，可怕的是仅靠加班来追赶进度。这是问题的关键，长时间的赶工仍然无法赶上进度，这只意味着项目有某种更深层次的问题，已经不是单开赶工可以解决的了。留意那些长时间加班的项目，他们往往在管理上存在很大问题，发现这些问题，在你成为PM时，不要犯类似错误。</p>
<h1 id="怎样在复杂代码中找bug？"><a href="#怎样在复杂代码中找bug？" class="headerlink" title="怎样在复杂代码中找bug？"></a>怎样在复杂代码中找bug？</h1><ol>
<li><p>放大现象，有些bug现象不太明显，那么就想办法增大它的破坏性，把现象放大。这只是个思路，具体怎么放大只能根据具体的代码来定。比如：美剧《豪斯医生》里有一集，怀疑病人心肺有问题，就让病人去跑步机上跑步，加重心肺负担，从而放大症状。</p>
</li>
<li><p>二分法定位，把程序逻辑一点点注释掉，看看还会不会出问题，类似二分查找的方法，逐步缩小问题范围。</p>
</li>
<li><p>模拟现场，有时候我会问自己，如果我要实现bug描述的现象我要怎么写代码才行？比如：我遇到一个死锁问题，但是检查代码发现所有的锁都是配对的，没有忘记解锁的地方，而且锁很简单就是一个普通的临界段，保护几行赋值语句而已。这样的代码怎么写才能让他死锁呢？我想如果让我故意制造这样一个现象，只有在上锁的时候强制杀掉线程了，既然这样就可以去看看有谁强杀线程了没有。</p>
</li>
<li><p>制作工具，针对某些bug编写一些调试辅助工具。比如，我那个系统没有完善的崩溃报告，虽然也有dump，但是分析出来的callstack经常不准。于是我为解决崩溃问题编写了个工具，会自动扫描代码，在每个函数入口和出口插入log，以此来定位崩溃点。</p>
</li>
<li><p>掩盖问题，虽然这样做有点不厚道，但是有时不得不这么做。有些bug找不到真正的root cause，但是又要在规定时间内解决，那么我们就可以治疗症状而不去找病因。比如用try catch掩盖一些奇怪的崩溃。不到万不得已不要这么干，未来可能会付出更大代价。</p>
</li>
</ol>
<p>减少 bug 的第一步，是提升自己的程序员素养，努力不给自己和别人找麻烦。</p>
<p>程序员新人怎样在复杂代码中找bug？</p>
<p>另外，团队协作也很重要，前期的技术方案和设计评审、代码审查，对减少一些重大的错误和弱智的 bug 都非常有好处。</p>
<p>与几个有经验的程序员一起评审一个技术方案，常常会发现一些重大的问题，比如为什么用缓存，为什么做持久化，高并发下怎么应对，这部分设计支持线程重入吗，这个循环为什么设置成10分钟，这个超时设置为什么是60秒，传输协议加密了吗，等等。很多方案可能会仅限于解决当前的问题，但有经验的程序员却能透过时间的重重迷雾，发现这个方案在未来某个时间点可能爆发的问题。这就是评审的力量。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;避免错误&quot;&gt;&lt;a href=&quot;#避免错误&quot; class=&quot;headerlink&quot; title=&quot;避免错误&quot;&gt;&lt;/a&gt;避免错误&lt;/h1&gt;&lt;h2 id=&quot;1、缺少必要的注释&quot;&gt;&lt;a href=&quot;#1、缺少必要的注释&quot; class=&quot;headerlink&quot; title=
    
    </summary>
    
      <category term="Essay" scheme="http://zhangfei.tk/categories/Essay/"/>
    
    
      <category term="Coding" scheme="http://zhangfei.tk/tags/Coding/"/>
    
  </entry>
  
  <entry>
    <title>MySQL常见性能优化</title>
    <link href="http://zhangfei.tk/2017/04/11/MySQL%E5%B8%B8%E8%A7%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://zhangfei.tk/2017/04/11/MySQL常见性能优化/</id>
    <published>2017-04-11T14:03:36.000Z</published>
    <updated>2017-07-05T14:45:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="优化Group-By语句"><a href="#优化Group-By语句" class="headerlink" title="优化Group By语句"></a>优化Group By语句</h1><p>默认情况下，MySQL 排序所有GROUP BY col1，col2，….。查询的方法如同在查询中指定ORDER BY col1，col2，…。如果显式包括一个包含相同的列的ORDER BY子句，MySQL 可以毫不减速地对它进行优化，尽管仍然进行排序。如果查询包括GROUP BY 但你想要避免排序结果的消耗，你可以指定ORDER BY NULL禁止排序。</p>
<h1 id="优化Order-by语句"><a href="#优化Order-by语句" class="headerlink" title="优化Order by语句"></a>优化Order by语句</h1><p>在某些情况中，MySQL 可以使用一个索引来满足ORDER BY 子句，而不需要额外的排序。where 条件和order by 使用相同的索引，并且order by 的顺序和索引顺序相同，并且order by 的字段都是升序或者都是降序。</p>
<h1 id="优化insert语句"><a href="#优化insert语句" class="headerlink" title="优化insert语句"></a>优化insert语句</h1><p>如果你同时从同一客户插入很多行，使用多个值表的INSERT 语句。这比使用分开 INSERT 语句快(在一些情况中几倍)。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; insert into test values(1,2),(1,3),(1,4)…</div></pre></td></tr></table></figure>
<p>如果你从不同客户插入很多行，能通过使用INSERT DELAYED 语句得到更高的速度。Delayed 的含义是让insert 语句马上执行，其实数据都被放在内存的队列中，并没有真正的写入磁盘；这比每条语句都分别插入要快的多；LOW_PRIORITY刚好相反，在所有其他用户对表的读写完成后才进行插入。<br>将索引文件和数据文件分在不同的磁盘上存放（利用建表中的选项）；<br>如果进行批量插入，可以增加bulk_insert_buffer_size 变量值的方法来提高速度，但是，这只能对myisam表使用<br>当从一个文本文件装载一个表时，使用LOAD DATA INFILE。这通常比使用很多INSERT语句快20倍；<br>根据应用情况使用replace 语句代替insert；<br>根据应用情况使用ignore 关键字忽略重复记录。</p>
<h1 id="大批量插入数据"><a href="#大批量插入数据" class="headerlink" title="大批量插入数据"></a>大批量插入数据</h1><ol>
<li>对于Myisam 类型的表，可以通过以下方式快速的导入大量的数据。<br>ALTER TABLE tblname DISABLE KEYS;<br>这两个命令用来打开或者关闭Myisam 表非唯一索引的更新。在导入大量的数据到一个非空的Myisam 表时，通过设置这两个命令，可以提高导入的效率。对于导入大量数据到一个空的Myisam 表，默认就是先导入数据然后才创建索引的，所以不用进行设置。</li>
<li>而对于Innodb 类型的表，这种方式并不能提高导入数据的效率。对于Innodb 类型的表，我们有以下几种方式可以提高导入的效率：<br>a. 因为Innodb 类型的表是按照主键的顺序保存的，所以将导入的数据按照主键的顺序排列，可以有效的提高导入数据的效率。如果Innodb 表没有主键，那么系统会默认创建一个内部列作为主键，所以如果可以给表创建一个主键，将可以利用这个优势提高导入数据的效率。<br>b. 在导入数据前执行SET UNIQUE_CHECKS=0，关闭唯一性校验，在导入结束后执行SETUNIQUE_CHECKS=1，恢复唯一性校验，可以提高导入的效率。<br>c. 如果应用使用自动提交的方式，建议在导入前执行SET AUTOCOMMIT=0，关闭自动提交，导入结束后再执行SET AUTOCOMMIT=1，打开自动提交，也可以提高导入的效率。</li>
</ol>
<h1 id="查询的优化"><a href="#查询的优化" class="headerlink" title="查询的优化"></a>查询的优化</h1><p>读为主可以设置low_priority_updates=1，写的优先级调低，告诉MYSQL尽量先处理读求<br>为查询缓存优化你的查询<br>大多数的MySQL服务器都开启了查询缓存。这是提高性最有效的方法之一，而且这是被MySQL的数据库引擎处理的。当有很多相同的查询被执行了多次的时候，这些查询结果会被放到一个缓存中，这样，后续的相同的查询就不用操作表而直接访问缓存结果了。<br>这里最主要的问题是，对于程序员来说，这个事情是很容易被忽略的。因为，我们某些查询语句会让MySQL不使用缓存。请看下面的示例：<br>// 查询缓存不开启</p>
<h1 id="拆分大的-DELETE-或-INSERT-语句"><a href="#拆分大的-DELETE-或-INSERT-语句" class="headerlink" title="拆分大的 DELETE 或 INSERT 语句"></a>拆分大的 DELETE 或 INSERT 语句</h1><p>如果你需要在一个在线的网站上去执行一个大的 DELETE 或 INSERT 查询，你需要非常小心，要避免你的操作让你的整个网站停止相应。因为这两个操作是会锁表的，表一锁住了，别的操作都进不来了。<br>Apache 会有很多的子进程或线程。所以，其工作起来相当有效率，而我们的服务器也不希望有太多的子进程，线程和数据库链接，这是极大的占服务器资源的事情，尤其是内存。<br>如果你把你的表锁上一段时间，比如30秒钟，那么对于一个有很高访问量的站点来说，这30秒所积累的访问进程/线程，数据库链接，打开的文件数，可能不仅仅会让你泊WEB服务Crash，还可能会让你的整台服务器马上掛了。<br>所以，如果你有一个大的处理，你定你一定把其拆分，使用 LIMIT 条件是一个好的方法。</p>
<h1 id="where语句的优化"><a href="#where语句的优化" class="headerlink" title="where语句的优化"></a>where语句的优化</h1><ol>
<li>尽量避免在 where 子句中对字段进行表达式操作</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> uinfo_jifen <span class="keyword">where</span> jifen/<span class="number">60</span> &gt; <span class="number">10000</span>;</div></pre></td></tr></table></figure>
<p>优化后:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">Select</span> <span class="keyword">id</span> <span class="keyword">from</span> uinfo_jifen <span class="keyword">where</span> jifen&gt;<span class="number">600000</span>;</div></pre></td></tr></table></figure>
<ol>
<li>应尽量避免在where子句中对字段进行函数操作，这将导致mysql放弃使用索引</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> uid <span class="keyword">from</span> imid <span class="keyword">where</span> <span class="keyword">datediff</span>(create_time,<span class="string">'2011-11-22'</span>)=<span class="number">0</span></div></pre></td></tr></table></figure>
<p>优化后:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> uid <span class="keyword">from</span> imid <span class="keyword">where</span> create_time&gt; =<span class="string">'2011-11-21‘ and create_time&lt;‘2011-11-23’;</span></div></pre></td></tr></table></figure>
<h1 id="索引的优化"><a href="#索引的优化" class="headerlink" title="索引的优化"></a>索引的优化</h1><p>MySQL只有对以下操作符才使用索引：&lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN，以及某些时候的LIKE。<br>尽量不要写!=或者&lt;&gt;的sql，用between或&gt; and &lt;代替，否则可能用不到索引<br>Order by 、Group by 、Distinct 最好在需要这个列上建立索引，利于索引排序<br>尽量利用mysql索引排序<br>没办法的情况下，使用强制索引Force index(index_name)<br>尽量避勉innodb用非常大尺寸的字段作为主键<br>较频繁的作为查询条件的字段应该创建索引;<br>选择性高的字段比较适合创建索引;<br>作为表关联字段一般都需要创索引.<br>更新非常频繁的字段不适合创建索引;<br>不会出现在 WHERE 子句中的字段不该创建索引.<br>选择性太低的字段不适合单独创建索引</p>
<h1 id="尽量不要用子查询"><a href="#尽量不要用子查询" class="headerlink" title="尽量不要用子查询"></a>尽量不要用子查询</h1><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; explain select uid_,count(*) from smember_6 where uid_ in (select uid_ from alluid) group by uid_;</div><div class="line">--| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+--------------------+-----------+-------+---------------+---------+---------+------+----------+--------------------------+| 1 | PRIMARY | smember_6 | index | NULL | PRIMARY | 8 | NULL | 53431264 | Using where; Using index | | 2 | DEPENDENT SUBQUERY | alluid | ALL | NULL | NULL | NULL | NULL | 2448 | Using where |</div></pre></td></tr></table></figure>
<p>优化后:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; explain select a.uid_,count(*) from smember_6 a,alluid b where a.uid_=b.uid_ group by uid_;</div><div class="line">--| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+-------+------+---------------+---------+---------+------------+------+---------------------------------+| 1 | SIMPLE | b | ALL | NULL | NULL | NULL | NULL | 2671 | Using temporary; Using filesort | | 1 | SIMPLE | a | ref | PRIMARY | PRIMARY | 4 | ssc.b.uid_ | 1 | Using index</div></pre></td></tr></table></figure>
<h1 id="Join的优化"><a href="#Join的优化" class="headerlink" title="Join的优化"></a>Join的优化</h1><p>如果你的应用程序有很多 JOIN 查询，你应该确认两个表中Join的字段是被建过索引的。这样，MySQL内部会启动为你优化Join的SQL语句的机制。<br>而且，这些被用来Join的字段，应该是相同的类型的。例如：如果你要把 DECIMAL 字段和一个 INT 字段Join在一起，MySQL就无法使用它们的索引。对于那些STRING类型，还需要有相同的字符集才行。（两个表的字符集有可能不一样）</p>
<h1 id="表的优化"><a href="#表的优化" class="headerlink" title="表的优化"></a>表的优化</h1><h2 id="尽可能的使用-NOT-NULL"><a href="#尽可能的使用-NOT-NULL" class="headerlink" title="尽可能的使用 NOT NULL"></a>尽可能的使用 NOT NULL</h2><p>除非你有一个很特别的原因去使用 NULL 值，你应该总是让你的字段保持 NOT NULL。<br>不要以为 NULL 不需要空间，其需要额外的空间，并且，在你进行比较的时候，你的程序会更复杂。<br>当然，这里并不是说你就不能使用NULL了，现实情况是很复杂的，依然会有些情况下，你需要使用NULL值。<br>下面摘自MySQL自己的文档：<br>“NULL columns require additional space in the row to record whether their values are NULL. For MyISAM tables, each NULL column takes one bit extra, rounded up to the nearest byte.”</p>
<h2 id="固定长度的表会更快"><a href="#固定长度的表会更快" class="headerlink" title="固定长度的表会更快"></a>固定长度的表会更快</h2><p>如果表中的所有字段都是“固定长度”的，整个表会被认为是 “static” 或 “fixed-length”。 例如，表中没有如下类型的字段： VARCHAR，TEXT，BLOB。只要你包括了其中一个这些字段，那么这个表就不是“固定长度静态表”了，这样，MySQL 引擎会用另一种方法来处理。<br>固定长度的表会提高性能，因为MySQL搜寻得会更快一些，因为这些固定的长度是很容易计算下一个数据的偏移量的，所以读取的自然也会很快。而如果字段不是定长的，那么，每一次要找下一条的话，需要程序找到主键。<br>并且，固定长度的表也更容易被缓存和重建。不过，唯一的副作用是，固定长度的字段会浪费一些空间，因为定长的字段无论你用不用，他都是要分配那么多的空间。</p>
<h2 id="垂直分割"><a href="#垂直分割" class="headerlink" title="垂直分割"></a>垂直分割</h2><p>“垂直分割”是一种把数据库中的表按列变成几张表的方法，这样可以降低表的复杂度和字段的数目，从而达到优化的目的。（以前，在银行做过项目，见过一张表有100多个字段，很恐怖）<br>示例一：在Users表中有一个字段是家庭地址，这个字段是可选字段，相比起，而且你在数据库操作的时候除了个人信息外，你并不需要经常读取或是改写这个字段。那么，为什么不把他放到另外一张表中呢？ 这样会让你的表有更好的性能，大家想想是不是，大量的时候，我对于用户表来说，只有用户ID，用户名，口令，用户角色等会被经常使用。小一点的表总是会有好的性能。<br>示例二： 你有一个叫 “last_login” 的字段，它会在每次用户登录时被更新。但是，每次更新时会导致该表的查询缓存被清空。所以，你可以把这个字段放到另一个表中，这样就不会影响你对用户ID，用户名，用户角色的不停地读取了，因为查询缓存会帮你增加很多性能。<br>另外，你需要注意的是，这些被分出去的字段所形成的表，你不会经常性地去Join他们，不然的话，这样的性能会比不分割时还要差，而且，会是极数级的下降。</p>
<h2 id="越小的列会越快"><a href="#越小的列会越快" class="headerlink" title="越小的列会越快"></a>越小的列会越快</h2><p>对于大多数的数据库引擎来说，硬盘操作可能是最重大的瓶颈。所以，把你的数据变得紧凑会对这种情况非常有帮助，因为这减少了对硬盘的访问。<br>参看 MySQL 的文档 Storage Requirements 查看所有的数据类型。<br>如果一个表只会有几列罢了（比如说字典表，配置表），那么，我们就没有理由使用 INT 来做主键，使用 MEDIUMINT, SMALLINT 或是更小的 TINYINT 会更经济一些。如果你不需要记录时间，使用 DATE 要比 DATETIME 好得多。<br>当然，你也需要留够足够的扩展空间，不然，你日后来干这个事，你会死的很难看，参看Slashdot的例子（2009年11月06日），一个简单的ALTER TABLE语句花了3个多小时，因为里面有一千六百万条数据。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;优化Group-By语句&quot;&gt;&lt;a href=&quot;#优化Group-By语句&quot; class=&quot;headerlink&quot; title=&quot;优化Group By语句&quot;&gt;&lt;/a&gt;优化Group By语句&lt;/h1&gt;&lt;p&gt;默认情况下，MySQL 排序所有GROUP BY col1，
    
    </summary>
    
      <category term="Essay" scheme="http://zhangfei.tk/categories/Essay/"/>
    
    
      <category term="Mysql" scheme="http://zhangfei.tk/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Git Commit message 的写法规范之《Angular 规范》</title>
    <link href="http://zhangfei.tk/2017/04/11/Git-Commit-message-%E7%9A%84%E5%86%99%E6%B3%95%E8%A7%84%E8%8C%83%E4%B9%8B%E3%80%8AAngular-%E8%A7%84%E8%8C%83%E3%80%8B/"/>
    <id>http://zhangfei.tk/2017/04/11/Git-Commit-message-的写法规范之《Angular-规范》/</id>
    <published>2017-04-11T12:47:40.000Z</published>
    <updated>2017-07-05T14:45:54.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>目前，社区有多种 Commit message 的写法规范。本文介绍<a href="https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#heading=h.greljkmo14y0" target="_blank" rel="external">《Angular 规范》</a>，这是目前使用最广的写法，比较合理和系统化，并且有配套的工具。 </p>
</blockquote>
<h1 id="一、Commit-message-的作用"><a href="#一、Commit-message-的作用" class="headerlink" title="一、Commit message 的作用"></a>一、Commit message 的作用</h1><p>格式化的Commit message，有几个好处。</p>
<h2 id="（1）提供更多的历史信息，方便快速浏览。"><a href="#（1）提供更多的历史信息，方便快速浏览。" class="headerlink" title="（1）提供更多的历史信息，方便快速浏览。"></a>（1）提供更多的历史信息，方便快速浏览。</h2><p>比如，下面的命令显示上次发布后的变动，每个commit占据一行。你只看行首，就知道某次 commit 的目的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git log &lt;last tag&gt; HEAD --pretty=format:%s</div></pre></td></tr></table></figure>
<h2 id="（2）可以过滤某些commit（比如文档改动），便于快速查找信息。"><a href="#（2）可以过滤某些commit（比如文档改动），便于快速查找信息。" class="headerlink" title="（2）可以过滤某些commit（比如文档改动），便于快速查找信息。"></a>（2）可以过滤某些commit（比如文档改动），便于快速查找信息。</h2><p>比如，下面的命令仅仅显示本次发布新增加的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git log &lt;last release&gt; HEAD --grep feature</div></pre></td></tr></table></figure>
<h2 id="（3）可以直接从commit生成Change-log。"><a href="#（3）可以直接从commit生成Change-log。" class="headerlink" title="（3）可以直接从commit生成Change log。"></a>（3）可以直接从commit生成Change log。</h2><p>Change Log 是发布新版本时，用来说明与上一个版本差异的文档，详见后文。</p>
<h1 id="二、Commit-message-的格式"><a href="#二、Commit-message-的格式" class="headerlink" title="二、Commit message 的格式"></a>二、Commit message 的格式</h1><p>每次提交，Commit message 都包括三个部分：Header，Body 和 Footer。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</div><div class="line">// 空一行</div><div class="line">&lt;body&gt;</div><div class="line">// 空一行</div><div class="line">&lt;footer&gt;</div></pre></td></tr></table></figure>
<p>其中，Header 是必需的，Body 和 Footer 可以省略。<br>不管是哪一个部分，任何一行都不得超过72个字符（或100个字符）。这是为了避免自动换行影响美观。</p>
<h2 id="2-1-Header"><a href="#2-1-Header" class="headerlink" title="2.1 Header"></a>2.1 Header</h2><p>Header部分只有一行，包括三个字段：type（必需）、scope（可选）和subject（必需）。</p>
<h3 id="（1）type"><a href="#（1）type" class="headerlink" title="（1）type"></a>（1）type</h3><ul>
<li>type用于说明 commit 的类别，只允许使用下面7个标识。</li>
<li>feat：新功能（feature）</li>
<li>fix：修补bug</li>
<li>docs：文档（documentation）</li>
<li>style： 格式（不影响代码运行的变动）</li>
<li>refactor：重构（即不是新增功能，也不是修改bug的代码变动）</li>
<li>test：增加测试</li>
<li>chore：构建过程或辅助工具的变动</li>
</ul>
<p>如果type为feat和fix，则该 commit 将肯定出现在 Change log 之中。其他情况（docs、chore、style、refactor、test）由你决定，要不要放入 Change log，建议是不要。</p>
<h3 id="（2）scope"><a href="#（2）scope" class="headerlink" title="（2）scope"></a>（2）scope</h3><p>scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。</p>
<h3 id="（3）subject"><a href="#（3）subject" class="headerlink" title="（3）subject"></a>（3）subject</h3><p>subject是 commit 目的的简短描述，不超过50个字符。<br>以动词开头，使用第一人称现在时，比如change，而不是changed或changes<br>第一个字母小写<br>结尾不加句号（.）</p>
<h2 id="2-2-Body"><a href="#2-2-Body" class="headerlink" title="2.2 Body"></a>2.2 Body</h2><p>Body 部分是对本次 commit 的详细描述，可以分成多行。下面是一个范例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">More detailed explanatory text, if necessary.  Wrap it to </div><div class="line">about 72 characters or so. </div><div class="line"></div><div class="line">Further paragraphs come after blank lines.</div><div class="line"></div><div class="line">- Bullet points are okay, too</div><div class="line">- Use a hanging indent</div></pre></td></tr></table></figure>
<p>有两个注意点。<br>（1）使用第一人称现在时，比如使用change而不是changed或changes。<br>（2）应该说明代码变动的动机，以及与以前行为的对比。</p>
<h2 id="2-3-Footer"><a href="#2-3-Footer" class="headerlink" title="2.3 Footer"></a>2.3 Footer</h2><p>Footer 部分只用于两种情况。</p>
<h3 id="（1）不兼容变动"><a href="#（1）不兼容变动" class="headerlink" title="（1）不兼容变动"></a>（1）不兼容变动</h3><p>如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">BREAKING CHANGE: isolate scope bindings definition has changed.</div><div class="line"></div><div class="line">    To migrate the code follow the example below:</div><div class="line"></div><div class="line">    Before:</div><div class="line"></div><div class="line">    scope: &#123;</div><div class="line">      myAttr: &apos;attribute&apos;,</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    After:</div><div class="line"></div><div class="line">    scope: &#123;</div><div class="line">      myAttr: &apos;@&apos;,</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    The removed `inject` wasn&apos;t generaly useful for directives so there should be no code using it.</div></pre></td></tr></table></figure>
<h3 id="（2）关闭-Issue"><a href="#（2）关闭-Issue" class="headerlink" title="（2）关闭 Issue"></a>（2）关闭 Issue</h3><p>如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Closes #234</div></pre></td></tr></table></figure>
<p>也可以一次关闭多个 issue 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Closes #123, #245, #992</div></pre></td></tr></table></figure>
<h2 id="2-4-Revert"><a href="#2-4-Revert" class="headerlink" title="2.4 Revert"></a>2.4 Revert</h2><p>还有一种特殊情况，如果当前 commit 用于撤销以前的 commit，则必须以revert:开头，后面跟着被撤销 Commit 的 Header。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">revert: feat(pencil): add &apos;graphiteWidth&apos; option</div><div class="line"></div><div class="line">This reverts commit 667ecc1654a317a13331b17617d973392f415f02.</div></pre></td></tr></table></figure>
<p>Body部分的格式是固定的，必须写成This reverts commit &lt;hash&gt;.，其中的hash是被撤销 commit 的 SHA 标识符。<br>如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的Reverts小标题下面。</p>
<h1 id="三、Commitizen"><a href="#三、Commitizen" class="headerlink" title="三、Commitizen"></a>三、Commitizen</h1><p>Commitizen是一个撰写合格 Commit message 的工具。<br>安装命令如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install -g commitizen</div></pre></td></tr></table></figure>
<p>然后，在项目目录里，运行下面的命令，使其支持 Angular 的 Commit message 格式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ commitizen init cz-conventional-changelog --save --save-exact</div></pre></td></tr></table></figure>
<p>以后，凡是用到git commit命令，一律改为使用git cz。这时，就会出现选项，用来生成符合格式的 Commit message。</p>
<h1 id="四、validate-commit-msg"><a href="#四、validate-commit-msg" class="headerlink" title="四、validate-commit-msg"></a>四、validate-commit-msg</h1><p>validate-commit-msg 用于检查 Node 项目的 Commit message 是否符合格式。<br>它的安装是手动的。首先，拷贝下面这个JS文件，放入你的代码库。文件名可以取为validate-commit-msg.js。<br>接着，把这个脚本加入 Git 的 hook。下面是在package.json里面使用 ghooks，把这个脚本加为commit-msg时运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&quot;config&quot;: &#123;</div><div class="line">  &quot;ghooks&quot;: &#123;</div><div class="line">    &quot;commit-msg&quot;: &quot;./validate-commit-msg.js&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后，每次git commit的时候，这个脚本就会自动检查 Commit message 是否合格。如果不合格，就会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git add -A </div><div class="line">$ git commit -m &quot;edit markdown&quot; </div><div class="line">INVALID COMMIT MSG: does not match &quot;&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&quot; ! was: edit markdown</div></pre></td></tr></table></figure>
<h1 id="五、生成-Change-log"><a href="#五、生成-Change-log" class="headerlink" title="五、生成 Change log"></a>五、生成 Change log</h1><p>如果你的所有 Commit 都符合 Angular 格式，那么发布新版本时， Change log 就可以用脚本自动生成（例1，例2，例3）。<br>生成的文档包括以下三个部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">New features</div><div class="line">Bug fixes</div><div class="line">Breaking changes.</div></pre></td></tr></table></figure>
<p>每个部分都会罗列相关的 commit ，并且有指向这些 commit 的链接。当然，生成的文档允许手动修改，所以发布前，你还可以添加其他内容。<br>conventional-changelog 就是生成 Change log 的工具，运行下面的命令即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ npm install -g conventional-changelog</div><div class="line">$ cd my-project</div><div class="line">$ conventional-changelog -p angular -i CHANGELOG.md -w</div></pre></td></tr></table></figure>
<p>上面命令不会覆盖以前的 Change log，只会在CHANGELOG.md的头部加上自从上次发布以来的变动。<br>如果你想生成所有发布的 Change log，要改为运行下面的命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ conventional-changelog -p angular -i CHANGELOG.md -w -r 0</div></pre></td></tr></table></figure>
<p>为了方便使用，可以将其写入package.json的scripts字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;scripts&quot;: &#123;</div><div class="line">    &quot;changelog&quot;: &quot;conventional-changelog -p angular -i CHANGELOG.md -w -r 0&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以后，直接运行下面的命令即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm run changelog</div></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>转自<a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html</a></p>
</blockquote>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;目前，社区有多种 Commit message 的写法规范。本文介绍&lt;a href=&quot;https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/e
    
    </summary>
    
      <category term="Essay" scheme="http://zhangfei.tk/categories/Essay/"/>
    
    
      <category term="Git" scheme="http://zhangfei.tk/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Docker可视化管理工具Shipyard安装与配置</title>
    <link href="http://zhangfei.tk/2017/04/11/Docker%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7Shipyard%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <id>http://zhangfei.tk/2017/04/11/Docker可视化管理工具Shipyard安装与配置/</id>
    <published>2017-04-11T11:10:20.000Z</published>
    <updated>2017-07-05T14:45:54.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><strong>文章来源： <a href="https://shipyard-project.com/docs/deploy/automated/" target="_blank" rel="external">Shipyard Automated Deployment</a></strong></p>
</blockquote>
<hr>
<h1 id="Shipyard简介"><a href="#Shipyard简介" class="headerlink" title="Shipyard简介"></a>Shipyard简介</h1><p>Shipyard是一个集成管理docker容器、镜像、Registries的系统，它具有以下特点：</p>
<ul>
<li>支持多节点的集成管理</li>
<li>可动态加载节点</li>
<li>可托管node下的容器</li>
</ul>
<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ docker pull rethinkdb</div><div class="line">$ docker pull microbox/etcd</div><div class="line">$ docker pull shipyard/docker-proxy</div><div class="line">$ docker pull swarm </div><div class="line">$ docker pull shipyard/shipyard</div></pre></td></tr></table></figure>
<h2 id="自动安装"><a href="#自动安装" class="headerlink" title="自动安装"></a>自动安装</h2><p>注意：这将会暴露Docker Engine的管理端口2375。如果此节点在安全网络外部可以访问，建议使用TLS。</p>
<h3 id="下载自动部署Shell脚本"><a href="#下载自动部署Shell脚本" class="headerlink" title="下载自动部署Shell脚本"></a>下载自动部署Shell脚本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ curl -sSL https://shipyard-project.com/deploy | bash -s</div></pre></td></tr></table></figure>
<p>自动部署脚本中， 包括以下参数：</p>
<ul>
<li>ACTION： 表示可以使用的指令，它包括以下选项。</li>
<li>deploy， 默认值， 表示自动安装部署Shipyard管理工具及相关应用</li>
<li>upgrade，更新已存在的实例（注意：你要保持相同的系统环境、变量来部署同样的配置）</li>
<li>node， 部署Swarm的一个新节点</li>
<li>remove， 已存在的shipyard实例</li>
<li>DISCOVERY: 集群系统采用Swarm进行采集和管理(在节点管理中可以使用‘node’)</li>
<li>IMAGE: 镜像，默认使用shipyard的镜像</li>
<li>PREFIX: 容器名字的前缀</li>
<li>SHIPYARD_ARGS: 容器的常用参数</li>
<li>TLS_CERT_PATH: TLS证书路径</li>
<li>PORT: 主程序监听端口 (默认端口: 8080)</li>
<li>PROXY_PORT: 代理端口 (默认: 2375)</li>
</ul>
<h3 id="使用镜像"><a href="#使用镜像" class="headerlink" title="使用镜像"></a>使用镜像</h3><p>Shipyard允许您采取指定的镜像来部署实例，比如以下的测试版本，你也已这样做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ curl -sSL https://shipyard-project.com/deploy | IMAGE=shipyard/shipyard:test bash -s</div></pre></td></tr></table></figure>
<h3 id="使用前缀"><a href="#使用前缀" class="headerlink" title="使用前缀"></a>使用前缀</h3><p>你可以在部署Shipyard管理工具时，自定义你想要的前缀，比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ curl -sSL https://shipyard-project.com/deploy | PREFIX=shipyard-test bash -s</div></pre></td></tr></table></figure>
<h3 id="使用运行参数"><a href="#使用运行参数" class="headerlink" title="使用运行参数"></a>使用运行参数</h3><p>这里增加一些shipyard运行参数，你可以像这样进行调整：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ curl -sSL https://shipyard-project.com/deploy | SHIPYARD_ARGS=&quot;--ldap-server=ldap.example.com --ldap-autocreate-users&quot; bash -s</div></pre></td></tr></table></figure>
<h3 id="使用安全认证-TLS证书"><a href="#使用安全认证-TLS证书" class="headerlink" title="使用安全认证(TLS证书)"></a>使用安全认证(TLS证书)</h3><p>启用安全加密通讯协议（TLS）对Shipyard进行部署，包括代理（docker-proxy）、swarm集群、shipyard管理平台的配置，这是一个配置规范。证书必须采用以下命名规范：</p>
<ul>
<li>ca.pem: 安全认证证书</li>
<li>server.pem: 服务器证书</li>
<li>server-key.pem: 服务器私有证书</li>
<li>cert.pem: 客户端证书</li>
<li>key.pem: 客户端证书的key</li>
</ul>
<p>注意：证书将被放置在一个单独的安全认证docker容器中，并在各个组成部分之间共享。如果需要调试，可以将此容器连接到调试容器。数据容器名称为$PREFIX-certs。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ docker run --rm \ </div><div class="line">   -v $(pwd)/certs:/certs \ </div><div class="line">   ehazlett/certm \ -d /certs \ </div><div class="line">   bundle \ </div><div class="line">   generate \</div><div class="line">   -o shipyard \ </div><div class="line">   --host proxy \ </div><div class="line">   --host 127.0.0.1</div></pre></td></tr></table></figure>
<p>你也可以在部署时，指定TLS_CERT_PATH参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ curl -sSL https://shipyard-project.com/deploy | TLS_CERT_PATH=$(pwd)/certs bash -s</div></pre></td></tr></table></figure>
<h3 id="增加Swarm节点"><a href="#增加Swarm节点" class="headerlink" title="增加Swarm节点"></a>增加Swarm节点</h3><p>Shipyard管理的Swarm节点部署脚本将自动的安装key/value存储系统（etcd系统），用于进行服务发现， 相关的工具还有Consul、Zookeeper。增加一个节点到swarm集群，你可以通过以下的节点部署脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ curl -sSL https://shipyard-project.com/deploy | ACTION=node DISCOVERY=etcd://10.0.1.10:4001 bash -s</div></pre></td></tr></table></figure>
<p>注意：10.0.1.10该ip地址为部署Ectd系统所在主机的IP地址，你需要根据你的部署位置进行修改。</p>
<h3 id="删除Shipyard管理工具"><a href="#删除Shipyard管理工具" class="headerlink" title="删除Shipyard管理工具"></a>删除Shipyard管理工具</h3><p>如果你要删除Shipyard部署的容器，你可以使用以下脚本进行删除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ curl -sSL https://shipyard-project.com/deploy | ACTION=remove bash -s</div></pre></td></tr></table></figure>
<h2 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h2><h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><p>Shipyard使用RethinkDB做为数据存储工具， 我们需要先运行RethinkDB容器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ docker run \ </div><div class="line">    -ti \ </div><div class="line">    -d \ </div><div class="line">    --restart=always \ </div><div class="line">    --name shipyard-rethinkdb \ </div><div class="line">    rethinkdb</div></pre></td></tr></table></figure>
<h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>为了启用Swarm leader选择，我们必须使用来自Swarm容器的外部键值存储。此处，我们使用Etcd作为服务发现工具。可以选用的服务发现工具还有Consul、Zookeeper等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ docker run \ </div><div class="line">     -ti \ </div><div class="line">     -d \ </div><div class="line">     -p 4001:4001 \ </div><div class="line">     -p 7001:7001 \ </div><div class="line">     --restart=always \ </div><div class="line">     --name shipyard-discovery \ </div><div class="line">     microbox/etcd:latest \</div><div class="line">     -name discovery</div></pre></td></tr></table></figure>
<h3 id="Docker代理服务"><a href="#Docker代理服务" class="headerlink" title="Docker代理服务"></a>Docker代理服务</h3><p>默认情况下，Docker引擎只侦听套接字。 我们可以重新配置引擎以使用TLS，或者您可以使用代理容器。 这是一个非常轻量级的容器，它只是将请求从TCP转发到Docker监听的Unix套接字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ docker run \ </div><div class="line">   -ti \ </div><div class="line">   -d \ </div><div class="line">   -p 2375:2375 \ </div><div class="line">   --hostname=$HOSTNAME \ </div><div class="line">   --restart=always \ </div><div class="line">   --name shipyard-proxy \ </div><div class="line">    -v /var/run/docker.sock:/var/run/docker.sock \ </div><div class="line">    -e PORT=2375 \ </div><div class="line">   shipyard/docker-proxy:latest</div></pre></td></tr></table></figure>
<h3 id="Swarm管理节点"><a href="#Swarm管理节点" class="headerlink" title="Swarm管理节点"></a>Swarm管理节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ docker run \ </div><div class="line">   -ti \ </div><div class="line">   -d \ </div><div class="line">   --restart=always \ </div><div class="line">   --name shipyard-swarm-manager \ </div><div class="line">   swarm:latest \ </div><div class="line">   manage --host tcp://0.0.0.0:3375 etcd://&lt;IP-OF-HOST&gt;:4001</div></pre></td></tr></table></figure>
<h3 id="Swarm-Agent节点"><a href="#Swarm-Agent节点" class="headerlink" title="Swarm Agent节点"></a>Swarm Agent节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ docker run \ </div><div class="line">   -ti \ </div><div class="line">   -d \ </div><div class="line">   --restart=always \ </div><div class="line">   --name shipyard-swarm-agent \ </div><div class="line">   swarm:latest \ </div><div class="line">   join --addr &lt;ip-of-host&gt;:2375 etcd://&lt;ip-of-host&gt;:4001</div></pre></td></tr></table></figure>
<h3 id="Shipyard管理工具"><a href="#Shipyard管理工具" class="headerlink" title="Shipyard管理工具"></a>Shipyard管理工具</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ docker run \ </div><div class="line">   -ti \ </div><div class="line">   -d \ </div><div class="line">   --restart=always \ </div><div class="line">   --name shipyard-controller \ </div><div class="line">   --link shipyard-rethinkdb:rethinkdb \ </div><div class="line">   --link shipyard-swarm-manager:swarm \ </div><div class="line">   -p 8080:8080 \ </div><div class="line">   shipyard/shipyard:latest \ </div><div class="line">   server \ </div><div class="line">   -d tcp://swarm:3375</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;文章来源： &lt;a href=&quot;https://shipyard-project.com/docs/deploy/automated/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Shipyard Automate
    
    </summary>
    
      <category term="Collection" scheme="http://zhangfei.tk/categories/Collection/"/>
    
    
      <category term="Docker" scheme="http://zhangfei.tk/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>JAVA不借助中间变量交换2个变量的值</title>
    <link href="http://zhangfei.tk/2017/04/09/JAVA%E4%B8%8D%E5%80%9F%E5%8A%A9%E4%B8%AD%E9%97%B4%E5%8F%98%E9%87%8F%E4%BA%A4%E6%8D%A22%E4%B8%AA%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC/"/>
    <id>http://zhangfei.tk/2017/04/09/JAVA不借助中间变量交换2个变量的值/</id>
    <published>2017-04-09T05:29:50.000Z</published>
    <updated>2017-07-05T14:45:54.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="comment">/*方法一*/</span></div><div class="line">    <span class="keyword">int</span> a = <span class="number">3</span>;</div><div class="line">    <span class="keyword">int</span> b = <span class="number">4</span>;</div><div class="line">    a=a+b;</div><div class="line">    b=a-b;</div><div class="line">    a=a-b;</div><div class="line">    System.out.println(<span class="string">"a="</span>+a+<span class="string">",b="</span>+b);</div><div class="line">    </div><div class="line">    <span class="comment">/*方法二利用位运算交换，效率很高*/</span></div><div class="line">    <span class="keyword">int</span> aa=<span class="number">3</span>;</div><div class="line">    <span class="keyword">int</span> bb=<span class="number">4</span>;</div><div class="line">    aa=aa^bb;</div><div class="line">    bb=bb^aa;</div><div class="line">    aa=aa^bb;</div><div class="line">    System.out.println(<span class="string">"aa="</span>+aa+<span class="string">",bb="</span>+bb);</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div
    
    </summary>
    
      <category term="Essay" scheme="http://zhangfei.tk/categories/Essay/"/>
    
    
      <category term="Java" scheme="http://zhangfei.tk/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Spring模块及生态支持汇总</title>
    <link href="http://zhangfei.tk/2017/04/09/Spring%E6%A8%A1%E5%9D%97%E5%8F%8A%E7%94%9F%E6%80%81%E6%94%AF%E6%8C%81%E6%B1%87%E6%80%BB/"/>
    <id>http://zhangfei.tk/2017/04/09/Spring模块及生态支持汇总/</id>
    <published>2017-04-09T05:06:51.000Z</published>
    <updated>2017-07-05T14:45:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Spring模块"><a href="#一、Spring模块" class="headerlink" title="一、Spring模块"></a>一、Spring模块</h1><h2 id="（1）核心容器"><a href="#（1）核心容器" class="headerlink" title="（1）核心容器"></a>（1）核心容器</h2><ul>
<li>Spring-Core：核心工具类，Spring其他模块大量使用Spring-Core</li>
<li>Spring-Bean：Spring定义Bean的支持</li>
<li>Spring-Context：运行时Spring容器</li>
<li>Spring-Context-Support：Spring容器对第三方包的集成支持</li>
<li>Spring-Expression：使用表达式语言在运行时查询和操作对象</li>
</ul>
<h2 id="（2）AOP"><a href="#（2）AOP" class="headerlink" title="（2）AOP"></a>（2）AOP</h2><ul>
<li>Spring-Aop：基于代理的AOP支持</li>
<li>Spring-Aspects：基于AspectJ的AOP支持</li>
</ul>
<h2 id="（3）消息-message"><a href="#（3）消息-message" class="headerlink" title="（3）消息(message)"></a>（3）消息(message)</h2><ul>
<li>Spring-Messaging：对消息架构和协议的支持</li>
</ul>
<h2 id="（4）Web"><a href="#（4）Web" class="headerlink" title="（4）Web"></a>（4）Web</h2><ul>
<li>Spring-Web：提供基础的Web集成功能，在Web项目中提供Spring的容器</li>
<li>Spring-Webmvc：提供基于Servlet的Spring MVC</li>
<li>Spring-WebSocket：提供WebSocket功能</li>
<li>Spring-Webmvc-Portlet：提供Portlet环境支持</li>
</ul>
<h2 id="（5）数据访问-集成（Data-Access-Integration）"><a href="#（5）数据访问-集成（Data-Access-Integration）" class="headerlink" title="（5）数据访问/集成（Data Access/Integration）"></a>（5）数据访问/集成（Data Access/Integration）</h2><ul>
<li>Spring-JDBC：提供以JDBC访问数据库的支持</li>
<li>Spring-TX：提供编程式和声明式的事务支持</li>
<li>Spring-ORM：提供对对象/关系映射技术的支持</li>
<li>Spring-OXM：提供对对象/xml映射技术的支持</li>
<li>Spring-JMS：提供对JMS的支持</li>
</ul>
<h1 id="二、Spring的生态"><a href="#二、Spring的生态" class="headerlink" title="二、Spring的生态"></a>二、Spring的生态</h1><p>Spring发展到现在已经不仅仅是Spring框架本身的内容，Spring目前提供了大量的基于Spring的项目，可以用来更深入地降低我们的开发难度，提高开发效率。<br>目前Spring的生态里主要有以下项目，我们可以根据自己项目的需要来选择使用相应的项目：</p>
<ul>
<li>Spring Boot：使用默认开发配置来实现快捷开发</li>
<li>Spring XD：用来简化大数据应用开发</li>
<li>Spring Cloud：为分布式系统开发提供工具集</li>
<li>Spring Data：对主流的关系型和Nosql数据库的支持</li>
<li>Spring Integration：通过消息机制对企业集成模式（EIP）的支持</li>
<li>Spring Batch：简化及优化大量数据的批处理操作</li>
<li>Spring Security：通过认证和授权保护应用</li>
<li>Spring HATEOAS：基于HATEOAS原则简化REST服务开发</li>
<li>Spring Social：于社交网络API（如Facebook、新浪微博等）的集成</li>
<li>Spring AMQP：对基于AMQP的消息的支持</li>
<li>Spring Mobile：提供对手机设备检测的功能，给不同的设备返回不同的页面的支持</li>
<li>Spring for Android：主要提供在Android上消费Restful API的功能</li>
<li>Spring Web Flow：基于Spring MVC提供基于向导流程式的Web应用开发</li>
<li>Spring Web Services：提供基于协议有限的SOAP/Web服务</li>
<li>Spring LDAP：简化LDAP开发</li>
<li>Spring Session：提供一个API及实现来管理用户会话信息</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、Spring模块&quot;&gt;&lt;a href=&quot;#一、Spring模块&quot; class=&quot;headerlink&quot; title=&quot;一、Spring模块&quot;&gt;&lt;/a&gt;一、Spring模块&lt;/h1&gt;&lt;h2 id=&quot;（1）核心容器&quot;&gt;&lt;a href=&quot;#（1）核心容器&quot; class
    
    </summary>
    
      <category term="Essay" scheme="http://zhangfei.tk/categories/Essay/"/>
    
    
      <category term="Java" scheme="http://zhangfei.tk/tags/Java/"/>
    
      <category term="Spring" scheme="http://zhangfei.tk/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Java中创建对象的5种不同方法</title>
    <link href="http://zhangfei.tk/2017/04/08/Java%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%845%E7%A7%8D%E4%B8%8D%E5%90%8C%E6%96%B9%E6%B3%95/"/>
    <id>http://zhangfei.tk/2017/04/08/Java中创建对象的5种不同方法/</id>
    <published>2017-04-08T10:13:23.000Z</published>
    <updated>2017-07-05T14:45:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为Java开发者，我们每天都会创建大量的对象，但是，我们总是使用管理依赖系统（如Spring框架）来创建这些对象。其实还有其他方法可以创建对象，在接下来的文章中我会进行详细介绍。<br>1.使用new关键字<br>这是最常见的创建对象的方法，并且也非常简单。通过使用这种方法我们可以调用任何我们需要调用的构造函数。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Employee emp1 = new Employee();</div><div class="line">0: new #19 // class org/programming/mitra/exercises/Employee 3: dup 4: invokespecial #21 // Method org/programming/mitra/exercises/Employee."":V</div></pre></td></tr></table></figure></p>
<p>2.使用class类的newInstance方法<br>我们也可以使用class类的newInstance方法来创建对象。此newInstance方法调用无参构造函数以创建对象。<br>我们可以通过newInstance 用以下方式创建对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Employee emp2 = (Employee) Class.forName(<span class="string">"org.programming.mitra.exercises.Employee"</span>).newInstance;</div></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Employee emp2 = Employee.class.newInstance;</div><div class="line">51: invokevirtual #70 // Method java/lang/Class.newInstance:Ljava/lang/Object;</div></pre></td></tr></table></figure></p>
<p>3.使用构造函数类的 newInstance方法<br>与使用class类的newInstance方法相似，java.lang.reflect.Constructor类中有一个可以用来创建对象的newInstance函数方法。通过使用这个newInstance方法我们也可以调用参数化构造函数和私有构造函数。<br>Constructor<br>111: invokevirtual #80 // Method java/lang/reflect/Constructor.newInstance:([Ljava/lang/Object;)Ljava/lang/Object;<br>这些 newInstance 方法被认为是创建对象的反射手段。实际上，内部类的newInstance方法使用构造函数类的 newInstance 方法。这就是为什么后者是首选并且使用不同的框架如Spring, Hibernate, Struts等。<br>4.使用clone方法<br>实际上无论何时我们调用clone 方法，JAVA虚拟机都为我们创建了一个新的对象并且复制了之前对象的内容到这个新的对象中。使用 clone方法创建对象不会调用任何构造函数。<br>为了在对象中使用clone方法，我们需要在其中实现可克隆类型并定义clone方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Employee emp4 = (Employee) emp3.clone();</div><div class="line">162: invokevirtual #87 // Method org/programming/mitra/exercises/Employee.clone Ljava/lang/Object;</div></pre></td></tr></table></figure></p>
<p>5.使用反序列化<br>无论何时我们对一个对象进行序列化和反序列化，JAVA虚拟机都会为我们创建一个单独的对象。在反序列化中，JAVA虚拟机不会使用任何构造函数来创建对象。<br>对一个对象进行序列化需要我们在类中实现可序列化的接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;data.obj&quot;)); </div><div class="line">Employee emp5 = (Employee) in.readObject();</div><div class="line">invokevirtual #118 // Method java/io/ObjectInputStream.readObject:Ljava/lang/Object;</div></pre></td></tr></table></figure></p>
<p>正如我们在以上的字节代码片段中所看到的，除第一种被转换为一个新的函数和一个 invokespecial 指令以外，其它4种方法都被调用并转换为invokevirtual。<br>示例<br>让我们来看看准备创建对象的 Employee 类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Employee Constructor Called..."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> prime = <span class="number">31</span>;</div><div class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</div><div class="line">        result = (prime * result) + ((name == <span class="keyword">null</span>) ? <span class="number">0</span> : name.hashCode);</div><div class="line">        <span class="keyword">return</span> (result);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == obj) &#123;</div><div class="line">            <span class="keyword">return</span> (<span class="keyword">true</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> (<span class="keyword">false</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (getClass != obj.getClass) &#123;</div><div class="line">            <span class="keyword">return</span> (<span class="keyword">false</span>);</div><div class="line">        &#125;</div><div class="line">        Employee other = (Employee) obj;</div><div class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (other.name != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">return</span> (<span class="keyword">false</span>);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!name.equals(other.name)) &#123;</div><div class="line">            <span class="keyword">return</span> (<span class="keyword">false</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (<span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (<span class="string">"Employee [name="</span> + name + <span class="string">"]"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</div><div class="line">        Object obj = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            obj = <span class="keyword">super</span>.clone;</div><div class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</div><div class="line">            e.printStackTrace;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (obj);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在下面的Java程序中我们用5种方式来创建 Employee对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectCreation</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">// By using new keyword </span></div><div class="line">        Employee emp1 = <span class="keyword">new</span> Employee();</div><div class="line">        emp1.setName(<span class="string">"Naresh"</span>);</div><div class="line">        System.out.println(emp1 + <span class="string">", hashcode : "</span> + emp1.hashCode());</div><div class="line"></div><div class="line">        <span class="comment">// By using Class class's newInstance method </span></div><div class="line">        Employee emp2 = (Employee) Class.forName(<span class="string">"org.programming.mitra.exercises.Employee"</span>).newInstance();</div><div class="line">        <span class="comment">// Or we can simply do this // Employee emp2 = Employee.class.newInstance(); </span></div><div class="line">        emp2.setName(<span class="string">"Rishi"</span>);</div><div class="line">        System.out.println(emp2 + <span class="string">", hashcode : "</span> + emp2.hashCode());</div><div class="line"></div><div class="line">        <span class="comment">// By using Constructor class's newInstance method Constructor</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此程序输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Employee Constructor Called… Employee [name=Naresh], hashcode : -1968815046 </div><div class="line">Employee Constructor Called… Employee [name=Rishi], hashcode : 78970652 </div><div class="line">Employee Constructor Called… Employee [name=Yogesh], hashcode : -1641292792 </div><div class="line">Employee [name=Atul], hashcode : 2051657 Employee [name=Akash], hashcode : 63313419</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为Java开发者，我们每天都会创建大量的对象，但是，我们总是使用管理依赖系统（如Spring框架）来创建这些对象。其实还有其他方法可以创建对象，在接下来的文章中我会进行详细介绍。&lt;br&gt;1.使用new关键字&lt;br&gt;这是最常见的创建对象的方法，并且也非常简单。通过使用这种方
    
    </summary>
    
      <category term="Essay" scheme="http://zhangfei.tk/categories/Essay/"/>
    
    
      <category term="Java" scheme="http://zhangfei.tk/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>MYSQL建表规约</title>
    <link href="http://zhangfei.tk/2017/04/08/MYSQL%E5%BB%BA%E8%A1%A8%E8%A7%84%E7%BA%A6/"/>
    <id>http://zhangfei.tk/2017/04/08/MYSQL建表规约/</id>
    <published>2017-04-08T10:05:29.000Z</published>
    <updated>2017-07-05T14:45:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>【强制】表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint（ 1 表示是，0 表示否），此规则同样适用于 odps 建表。<br>说明：任何字段如果为非负数，必须是 unsigned。<br>举例：<code>is_star</code> tinyint unsigned DEFAULT NULL COMMENT ‘项目状态（1 表示是，0 表示否）’</p>
<hr>
<p>【强制】表名、字段名必须使用小写字母或数字；禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。<br>正例：getter_admin，task_config，level3_name<br>反例：GetterAdmin，taskConfig，level_3_name</p>
<hr>
<p>【强制】表名不使用复数名词。<br>说明：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于 DO 类名也是单数形式，符合表达习惯。</p>
<hr>
<p>【强制】禁用保留字，如 desc、range、match、delayed 等，参考官方保留字。</p>
<hr>
<p>【强制】唯一索引名为 uk<em>字段名；普通索引名则为 idx</em>字段名。<br>说明：uk<em> 即 unique key；idx</em> 即 index 的简称。</p>
<hr>
<p>【强制】小数类型为 decimal，禁止使用 float 和 double。<br>说明：float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。</p>
<hr>
<p>【强制】如果存储的字符串长度几乎相等，使用 CHAR 定长字符串类型。</p>
<hr>
<p>【强制】varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 TEXT，独立出来一张表，用主键来对应，避免影响其它字段索引效率。</p>
<hr>
<p>【强制】表必备三字段：id, gmt_create, gmt_modified。<br>说明：其中 id 必为主键，类型为 unsigned bigint、单表时自增、步长为 1； 分表时改为从TDDL Sequence 取值，确保分表之间的全局唯一。gmt_create, gmt_modified 的类型均为date_time 类型。</p>
<hr>
<p>【推荐】表的命名最好是加上“业务名称_表的作用”，避免上云梯后，再与其它业务表关联时有混淆。<br>正例：tiger_task / tiger_reader / mpp_config</p>
<hr>
<p>【推荐】库名与应用名称尽量一致。</p>
<hr>
<p>【推荐】如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。</p>
<hr>
<p>【推荐】字段允许适当冗余，以提高性能，但是必须考虑数据同步的情况。冗余字段应遵循：<br>1）不是频繁修改的字段。<br>2）不是 varchar 超长字段，更不能是 text 字段。<br>正例：各业务线经常冗余存储商品名称，避免查询时需要调用 IC 服务获取。</p>
<hr>
<p>【推荐】单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。<br>说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。<br>反例：某业务三年总数据量才 2 万行，却分成 1024 张表，问：你为什么这么设计？答：分 1024张表，不是标配吗？<br>【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。<br>正例：人的年龄用 unsigned tinyint（表示范围 0-255，人的寿命不会超过 255 岁）；海龟就必须是 smallint，但如果是太阳的年龄，就必须是 int；如果是所有恒星的年龄都加起来，那么就必须使用 bigint。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【强制】表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint（ 1 表示是，0 表示否），此规则同样适用于 odps 建表。&lt;br&gt;说明：任何字段如果为非负数，必须是 unsigned。&lt;br&gt;举例：&lt;code&gt;is_sta
    
    </summary>
    
      <category term="Essay" scheme="http://zhangfei.tk/categories/Essay/"/>
    
    
      <category term="Mysql" scheme="http://zhangfei.tk/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>MySQL里面这五个非常非常有用的东西</title>
    <link href="http://zhangfei.tk/2017/04/08/MySQL%E9%87%8C%E9%9D%A2%E8%BF%99%E4%BA%94%E4%B8%AA%E9%9D%9E%E5%B8%B8%E9%9D%9E%E5%B8%B8%E6%9C%89%E7%94%A8%E7%9A%84%E4%B8%9C%E8%A5%BF/"/>
    <id>http://zhangfei.tk/2017/04/08/MySQL里面这五个非常非常有用的东西/</id>
    <published>2017-04-08T10:02:04.000Z</published>
    <updated>2017-07-05T14:45:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL是非常流行的关系型数据库，虽然拥有的SQL语法大部分是符合ANSI SQL标准的，但是它自身还是携带了很多优秀的、私有的语句和指示符，今天我们就来分析一下。</p>
<h3 id="EXPLAIN"><a href="#EXPLAIN" class="headerlink" title="EXPLAIN"></a>EXPLAIN</h3><p>难度指数：★ ★ ★ ★ ★<br>推荐指数：★ ★ ★ ★ ★<br>当我们网站或者接口访问频率越来越大，这时如果我们的相关SQL语句执行时间很长的话，就很容易造成网站或者接口响应慢的情况，那么使用explain语句，我们能够清楚的知道MySQL是怎么执行我们的SQL语句的，执行某个查询语句总共查询了多少条记录，使用了什么表以及多表的链接顺序是怎么样的，该查询使用了哪些索引等等信息，有了这些信息，我们能够根据多次执行和分析优化我们的数据库，该建立索引的建索引，该删除的索引就删除掉。</p>
<h3 id="FOR-UPDATE"><a href="#FOR-UPDATE" class="headerlink" title="FOR UPDATE"></a>FOR UPDATE</h3><p>难度指数：★ ★ ☆ ☆ ☆<br>推荐指数：★ ★ ★ ★ ★<br>有时我们有这样的一种情况，就是需要将某个SELECT语句查询的行进行锁定，防止其他客户端修改，那么这个时候，我们可以使用这个指示符来完成。</p>
<h3 id="DELAYED"><a href="#DELAYED" class="headerlink" title="DELAYED"></a>DELAYED</h3><p>难度指数：★ ★ ☆ ☆ ☆<br>推荐指数：★ ★ ★ ★ ★<br>有时发现我们的产品的某个插入、更新操作不需要立即生效，也就是一些对读要求高、写要求不太高的应用，可以使用这个指示符，就是将这个插入或者修改后的数据不是立即写入到磁盘文件中去，而是等到MySQL数据库非常空闲的时候再进行写入的操作，从这里来看，这个指示符也算是一个小的优化性指示符。</p>
<h3 id="SQL-CACHE"><a href="#SQL-CACHE" class="headerlink" title="SQL_CACHE"></a>SQL_CACHE</h3><p>难度指数：★ ★ ☆ ☆ ☆<br>推荐指数：★ ★ ★ ★ ★<br>有时我们的产品读操作非常多，修改频率比较低，那么这个时候我们能够在执行select查询的时候指定sql_cache这个指示符，这样该查询语句和相应的查询结果将被缓存起来，那么下次执行同样的查询语句时，如果数据没有发生改变，那么将直接返回这个缓存的结果给客户端，从这里来看，这个查询语句指示符主要用于一些特性应用场景的优化操作。</p>
<h3 id="ON-DUPLICATE-KEY-UPDATE"><a href="#ON-DUPLICATE-KEY-UPDATE" class="headerlink" title="ON DUPLICATE KEY UPDATE"></a>ON DUPLICATE KEY UPDATE</h3><p>难度指数：★ ★ ☆ ☆ ☆<br>推荐指数：★ ★ ★ ★ ★<br>我们知道，在MySQL中有一个特殊的语句就是Replace语句，就是当插入的时候，我们发现某个条件（这里需要注意的是，这里指的是唯一索引或主键）的数据已经存在了，那么这个时候就先删除这条数据，然后再插入新的数据，也就是先删除再插入，但是有时候我们仅仅需要的是，如果存在了仅仅修改某个字段的值，而不是删除再插入，那么这个时候可以使用ON DUPLICATE KEY UPDATE来完成。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MySQL是非常流行的关系型数据库，虽然拥有的SQL语法大部分是符合ANSI SQL标准的，但是它自身还是携带了很多优秀的、私有的语句和指示符，今天我们就来分析一下。&lt;/p&gt;
&lt;h3 id=&quot;EXPLAIN&quot;&gt;&lt;a href=&quot;#EXPLAIN&quot; class=&quot;header
    
    </summary>
    
      <category term="Essay" scheme="http://zhangfei.tk/categories/Essay/"/>
    
    
      <category term="Mysql" scheme="http://zhangfei.tk/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>从地址栏输入URL到页面加载完成发生了什么？</title>
    <link href="http://zhangfei.tk/2017/04/08/%E4%BB%8E%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%88%90%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>http://zhangfei.tk/2017/04/08/从地址栏输入URL到页面加载完成发生了什么？/</id>
    <published>2017-04-08T09:52:26.000Z</published>
    <updated>2017-07-05T14:45:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>不管是前端还是后台开发，在找工作的时候，只要涉及到网络方面的知识，必然会问到这样一个问题：当我在浏览器的地址栏里输入一个完整的URL，在按下回车直至页面加载完成，整个过程发生了什么？这是一道考察综合能力的面试题，今天我们就一起来总结下该如何回答这个问题，当然我只是在这里讲解主要的知识点，涉及到的细节还需要大家再去找资料看。<br>整体过程<br>在这整个过程中，大致可以分为以下几个过程</p>
<ul>
<li>DNS域名解析</li>
<li>TCP连接</li>
<li>HTTP请求</li>
<li>处理请求返回HTTP响应</li>
<li>页面渲染</li>
<li>关闭连接</li>
<li>DNS域名解析</li>
</ul>
<p>首先我们应该要知道的是，在地址栏输入的域名并不是最后资源所在的真实位置，域名只是与IP地址的一个映射。网络服务器的IP地址那么多，我们不可能去记一串串的数字，因此域名就产生了，域名解析的过程实际是将域名还原为IP地址的过程。<br>DNS域名解析有两种方法，分别是迭代查询和递归查询</p>
<ul>
<li>迭代查询</li>
<li>递归查询</li>
</ul>
<p>TCP连接<br>在通过第一步的DNS域名解析后，获取到了服务器的IP地址，在获取到IP地址后，便会开始建立一次连接，这是由TCP协议完成的，主要通过三次握手进行连接。</p>
<p>三次握手<br>HTTP请求<br>在确认与服务器建立连接后，便会发送一个HTTP请求，HTTP请求的报文主要包括请求行，请求头，请求正文。<br>请求行的内容一般类似于：GET index.html HTTP/1.1<br>请求头的内容一般如下，可以通过浏览器开发者工具查看</p>
<p>请求头<br>请求体一般包含请求传递的参数</p>
<p>请求体<br>处理HTTP请求并响应<br>服务器在收到浏览器发送的HTTP请求之后，会将收到的HTTP报文封装成HTTP的Request对象，并通过不同的Web服务器进行处理，处理完的结果以HTTP的Response对象返回，主要包括状态码，响应头，响应报文三个部分。<br>状态码主要包括以下部分<br>1xx：指示信息–表示请求已接收，继续处理。<br>2xx：成功–表示请求已被成功接收、理解、接受。<br>3xx：重定向–要完成请求必须进行更进一步的操作。<br>4xx：客户端错误–请求有语法错误或请求无法实现。<br>5xx：服务器端错误–服务器未能实现合法的请求。<br>响应头主要由Cache-Control、 Connection、Date、Pragma等组成<br>响应体为服务器返回给浏览器的信息，主要由HTML，css，js，图片文件组成<br>页面渲染<br>页面DOM树的渲染是个复杂的过程，需要深入了解DOM原理，这里简要描述一下，主要过程如下</p>
<p>DOM树渲染<br>关闭连接<br>在页面元素传输完成后，会选择关闭连接，此时用到的是TCP四次挥手。</p>
<p>TCP四次挥手<br>总结<br>至此一个完成的URL从输入到加载的过程就分析完了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不管是前端还是后台开发，在找工作的时候，只要涉及到网络方面的知识，必然会问到这样一个问题：当我在浏览器的地址栏里输入一个完整的URL，在按下回车直至页面加载完成，整个过程发生了什么？这是一道考察综合能力的面试题，今天我们就一起来总结下该如何回答这个问题，当然我只是在这里讲解
    
    </summary>
    
      <category term="Essay" scheme="http://zhangfei.tk/categories/Essay/"/>
    
    
  </entry>
  
  <entry>
    <title>ElasticSearch + Canal 开发千万级的实时搜索系统</title>
    <link href="http://zhangfei.tk/2017/04/08/ElasticSearch-Canal-%E5%BC%80%E5%8F%91%E5%8D%83%E4%B8%87%E7%BA%A7%E7%9A%84%E5%AE%9E%E6%97%B6%E6%90%9C%E7%B4%A2%E7%B3%BB%E7%BB%9F/"/>
    <id>http://zhangfei.tk/2017/04/08/ElasticSearch-Canal-开发千万级的实时搜索系统/</id>
    <published>2017-04-08T09:50:29.000Z</published>
    <updated>2017-07-05T14:45:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>公司是做社交相关产品的，社交类产品对搜索功能需求要求就比较高，需要根据用户城市、用户ID昵称等进行搜索。<br>项目原先的搜索接口采用SQL查询的方式实现，数据库表采用了按城市分表的方式。但随着业务的发展，搜索接口调用频次越来越高，搜索接口压力越来越大，搜索数据库经常崩溃，从而导致搜索功能经常不能使用。<br>ElasticSearch + Canal 开发千万级的实时搜索系统<br>从上面的系统架构图可以看出，当用户修改资料时，接口会修改用户库信息，接着触发器会将改变的用户信息写入临时表。定时脚本每隔1分钟扫描一次临时表，将变更的数据写入到搜索库中。当用户再次请求搜索接口时，就可以搜索到最新的数据。<br>从技术层面分析，原搜索系统的设计有以下缺点：<br>搜索信息不实时。当用户修改信息时，需要等待1分钟的时间才能将最新的用户信息同步到搜索数据库中。<br>ID、昵称搜索速度慢。按照地区分表的数据库设计是为了减轻数据库压力，保证大部分按照地区搜索的请求能正常响应。但是如果用户按照ID或昵称搜索，那么我们就需要对成千上万个地区表全都搜索一次，这时间复杂度可想而知。很多时候按照昵称和ID搜索速度太慢，需要10多秒才能响应。<br>系统稳定性、拓展性以及处理能力差。这可以归结为技术老旧，无法满足业务需求。随着搜索量的提升，对数据库的压力将会越来越大，而MySQL数据库天然不适合用来应对海量的请求。现在已经有更加成熟的ElasticSearch可以用来做搜索方面的业务。<br>触发器不便于管理。触发器这种东西不好维护，并且扩展性很差，一旦修改的请求变多，很可能导致整个数据库崩溃（用户库崩溃是很严重的）。<br>我们总结一下新搜索系统需要解决的几个问题：<br>海量请求。几百万的请求毫无压力，上千万上亿也要可以扛得住。<br>实时搜索。指的是当一个用户修改了其数据之后，另一个用户能实时地搜索到改用户。<br>海量请求。要扛得起海量的搜索请求，可以使用ElasticSearch来实现，它是在Lucene的基础上进行封装的一个开源项目，它将Lucene复杂的原理以及API封装起来，对外提供了一个易用的API接口。ElasticSearch现在已经广泛地被许多公司使用，其中包括：爱奇艺、百姓网、58到家等公司。<br>实时搜索。阿里有一个开源项目Canal，就是用来解决这个问题的，Canal项目利用了MySQL数据库主从同步的原理，将Canal Server模拟成一台需要同步的从库，从而让主库将binlog日志流发送到Canal Server接口。Canal项目对binlog日志的解析进行了封装，我们可以直接得到解析后的数据，而不需要理会binlog的日志格式。而且Canal项目整合了zookeeper，整体实现了高可用，可伸缩性强，是一个不错的解决方案。<br>经过一段时间的技术预研，我们设计了整个搜索技术架构：<br>ElasticSearch + Canal 开发千万级的实时搜索系统<br>从架构图可以看出整个系统分为两大部分：<br>Canal数据变更服务平台。这部分负责解析MySQL的binlog日志，并将其解析后的数据封装成特定的对象放到Kafka中。<br>Kafka数据消费方。这部分负责消费存放在Kafka中的消息，当消费方拿到具体的用户表变更消息时，将最新的用户信息存放到ES数据仓库中。<br>Canal技术变更基础平台<br>因为考虑到未来可能有其他项目需要监控数据库某些表的变化，因此我们将Canal获取MySQL数据变更部分做成一个公用的平台。当有其他业务需要增加监控的表时，我们可以直接修改配置文件，重启服务器即可完成添加，极大地提高了开发效率。<br>在这一部分中，主要分为两大部分：Canal Server 和 Canal Client。<br>Canal Server端。Canal Server伪装成MySQL的一个从库，使主库发送binlog日志给 Canal Server，Canal Server 收到binlog消息之后进行解析，解析完成后将消息直接发送给Canal Client。在Canal Server端可以设置配置文件进行具体scheme（数据库）和table（数据库表）的筛选，从而实现动态地增加对数据库表的监视。<br>Canal Client端。Canal Client端接收到Canal Server的消息后直接将消息存到Kafka指定Partition中，并将最新的binlogid发送给zookeeper集群保存。<br>Kafka消息消费端<br>Canal技术变更平台在获取到对应的数据库变更消息后会将其放到指定的Kafka分片里，具体的业务项目需要到指定的Kafka片区里消费对应的数据变更消息，之后根据具体的业务需求进行处理。<br>因为Canal变化是根据表为最小单位进行地，因此我在实现方面定义了一个以表为处理单位的MsgDealer接口：<br>public interface MsgDealer { void deal(CanalMsgVo canalMsgVo); }<br>搜索库涉及对5个表的监视，因此我实现了5个对应的处理类：<br>ElasticSearch + Canal 开发千万级的实时搜索系统<br>针对不同表的数据变化，自动调用不同的实现类进行处理。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;公司是做社交相关产品的，社交类产品对搜索功能需求要求就比较高，需要根据用户城市、用户ID昵称等进行搜索。&lt;br&gt;项目原先的搜索接口采用SQL查询的方式实现，数据库表采用了按城市分表的方式。但随着业务的发展，搜索接口调用频次越来越高，搜索接口压力越来越大，搜索数据库经常崩溃，
    
    </summary>
    
      <category term="Essay" scheme="http://zhangfei.tk/categories/Essay/"/>
    
    
  </entry>
  
</feed>
