<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.2.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png"><link rel="mask-icon" href="/images/favicon/safari-pinned-tab.svg" color="#222"><meta name="msapplication-config" content="/images/favicon/browserconfig.xml"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"zhangfei.men",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:null},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!0,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!0,pangu:!0,comments:{style:"tabs",active:"valine",storage:!0,lazyload:!1,nav:null,activeClass:"valine"},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="Java 代理模式实现方式，主要有如下五种方法 静态代理，工程师编辑代理类代码，实现代理模式；在编译期就生成了代理类。 基于 JDK 实现动态代理，通过jdk提供的工具方法Proxy.newProxyInstance动态构建全新的代理类(继承Proxy类，并持有InvocationHandler接口引用 )字节码文件并实例化对象返回。(jdk动态代理是由java内部的反射机制来实例化代理对象，并代"><meta property="og:type" content="article"><meta property="og:title" content="Java动态代理、Cglib、AOP详解"><meta property="og:url" content="http://zhangfei.men/posts/3a5f5aec/index.html"><meta property="og:site_name" content="Zhangfei&#39;s Blog"><meta property="og:description" content="Java 代理模式实现方式，主要有如下五种方法 静态代理，工程师编辑代理类代码，实现代理模式；在编译期就生成了代理类。 基于 JDK 实现动态代理，通过jdk提供的工具方法Proxy.newProxyInstance动态构建全新的代理类(继承Proxy类，并持有InvocationHandler接口引用 )字节码文件并实例化对象返回。(jdk动态代理是由java内部的反射机制来实例化代理对象，并代"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2017-03-22T10:20:58.000Z"><meta property="article:modified_time" content="2020-07-28T01:08:16.453Z"><meta property="article:author" content="Zhang Fei"><meta property="article:tag" content="Java"><meta property="article:tag" content="Proxy"><meta property="article:tag" content="CGlib"><meta property="article:tag" content="AOP"><meta name="twitter:card" content="summary"><link rel="canonical" href="http://zhangfei.men/posts/3a5f5aec/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>Java动态代理、Cglib、AOP详解 | Zhangfei's Blog</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-104138524-1"></script><script>if(CONFIG.hostname===location.hostname){function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-104138524-1")}</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?adebe72cfd8e363da0f54dbd3032630d";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>!function(t,o,e,i,n){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},e=o.createElement("script"),tag=o.getElementsByTagName("script")[0],e.async=1,e.src=("https:"==document.location.protocol?"https://":"http://")+"assets.growingio.com/2.1/gio.js",tag.parentNode.insertBefore(e,tag)}(window,document,"script",0,"gio"),gio("init","3-wJ4Vc1s0T2ob2EFT0ejNdA0SF6iG4LD5qSwm8uW6A",{}),gio("send")</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="Zhangfei's Blog" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Zhangfei's Blog</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">Quick notes</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i> 首页</a></li><li class="menu-item menu-item-设计模式"><a href="/design-pattern/" rel="section"><i class="fa fa-cubes fa-fw"></i> 设计模式</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i> 关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i> 归档</a></li><li class="menu-item menu-item-schedule"><a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i> 日程表</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i> 站点地图</a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i> 公益 404</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a> <a href="https://github.com/zhangfei9734" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://zhangfei.men/posts/3a5f5aec/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://avatars2.githubusercontent.com/u/16345433?s=40&v=4"><meta itemprop="name" content="Zhang Fei"><meta itemprop="description" content="胡编一通，乱写一气"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Zhangfei's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> Java动态代理、Cglib、AOP详解</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2017-03-22 18:20:58" itemprop="dateCreated datePublished" datetime="2017-03-22T18:20:58+08:00">2017-03-22</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a></span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i></span> <span class="post-meta-item-text">Valine：</span><a title="valine" href="/posts/3a5f5aec/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/posts/3a5f5aec/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>33k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>30 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="Java-代理模式实现方式，主要有如下五种方法"><a href="#Java-代理模式实现方式，主要有如下五种方法" class="headerlink" title="Java 代理模式实现方式，主要有如下五种方法"></a>Java 代理模式实现方式，主要有如下五种方法</h2><ul><li>静态代理，工程师编辑代理类代码，实现代理模式；在编译期就生成了代理类。</li><li>基于 JDK 实现动态代理，通过jdk提供的工具方法Proxy.newProxyInstance动态构建全新的代理类(继承Proxy类，并持有InvocationHandler接口引用 )字节码文件并实例化对象返回。(jdk动态代理是由java内部的反射机制来实例化代理对象，并代理的调用委托类方法)</li><li>基于CGlib 动态代理模式 基于继承被代理类生成代理子类，不用实现接口。只需要被代理类是非final 类即可。(cglib动态代理底层是借助asm字节码技术</li><li>基于 Aspectj 实现动态代理（修改目标类的字节，织入代理的字节，在程序编译的时候 插入动态代理的字节码，不会生成全新的Class ）</li><li>基于 instrumentation 实现动态代理（修改目标类的字节码、类装载的时候动态拦截去修改，基于javaagent） <code>-javaagent:spring-instrument-4.3.8.RELEASE.jar</code> （类装载的时候 插入动态代理的字节码，不会生成全新的Class ）</li></ul><h2 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h2><ul><li>委托类 即指的是代理模式中的被代理对象</li><li>代理类 指的是生成的代表委托类的一个角色</li></ul><h2 id="静态代理实现"><a href="#静态代理实现" class="headerlink" title="静态代理实现"></a>静态代理实现</h2><p>静态代理是代理类在编译期间就创建好了，不是编译器生成的代理类，而是手动创建的类。在编译时就已经将接口，被代理类，代理类等确定下来。，软件设计中所指的代理一般是指静态代理，也就是在代码中显式指定的代理。</p><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ul><li>委托类和代理类之间的约束接口Cat</li><li>约束接口实现类 Lion，实现 Cat 接口，委托角色</li><li>代理类实现 FeederProxy，实现Cat 接口，并含有一个 Cat接口引用属性。 代理角色，代理 cat接口属性引用实例的行为并可以新增公共逻辑</li></ul><h4 id="Cat接口"><a href="#Cat接口" class="headerlink" title="Cat接口"></a>Cat接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.vincent.proxy.staticproxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> PengRong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@package</span> org.vincent.proxy.staticproxy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/12/15 - 17:12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ProjectName</span> JavaAopLearning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 静态代理类接口, 委托类和代理类都需要实现的接口规范。 定义了一个猫科动物的两个行为接口，吃东西，奔跑。 作为代理类 和委托类之间的约束接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">eatFood</span><span class="params">(String foodName)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">running</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="委托类-Lion"><a href="#委托类-Lion" class="headerlink" title="委托类 Lion"></a>委托类 Lion</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.vincent.proxy.staticproxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> PengRong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@package</span> org.vincent.proxy.staticproxy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/12/15 - 17:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ProjectName</span> JavaAopLearning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 狮子 实现了猫科动物接口Cat， 并实现了具体的行为。作为委托类实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lion</span> <span class="keyword">implements</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> runningSpeed;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRunningSpeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> runningSpeed;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRunningSpeed</span><span class="params">(<span class="keyword">int</span> runningSpeed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.runningSpeed = runningSpeed;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Lion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">eatFood</span><span class="params">(String foodName)</span> </span>&#123;</span><br><span class="line">    String eat = <span class="keyword">this</span>.name + <span class="string">" Lion eat food. foodName = "</span> + foodName;</span><br><span class="line">    System.out.println(eat);</span><br><span class="line">    <span class="keyword">return</span> eat;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">running</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="keyword">this</span>.name + <span class="string">" Lion is running . Speed :"</span> + <span class="keyword">this</span>.runningSpeed);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代理类角色-FeederProxy"><a href="#代理类角色-FeederProxy" class="headerlink" title="代理类角色(FeederProxy)"></a>代理类角色(FeederProxy)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.vincent.proxy.staticproxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> PengRong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@package</span> org.vincent.proxy.staticproxy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/12/15 - 17:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ProjectName</span> JavaAopLearning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 饲养员 实现Cat接口，作为静态代理类实现。代理狮子的行为。 代理类中可以新增一些其他行为，在实践中主要做的是参数校验的功能。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeederProxy</span> <span class="keyword">implements</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Cat cat;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FeederProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FeederProxy</span><span class="params">(Cat cat)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cat <span class="keyword">instanceof</span> Cat) &#123;</span><br><span class="line">      <span class="keyword">this</span>.cat = cat;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCat</span><span class="params">(Cat cat)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cat <span class="keyword">instanceof</span> Cat) &#123;</span><br><span class="line">      <span class="keyword">this</span>.cat = cat;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">eatFood</span><span class="params">(String foodName)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"proxy Lion exec eatFood "</span>);</span><br><span class="line">    <span class="keyword">return</span> cat.eatFood(foodName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">running</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"proxy Lion exec running."</span>);</span><br><span class="line">    <span class="keyword">return</span> cat.running();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态代理类测试"><a href="#静态代理类测试" class="headerlink" title="静态代理类测试"></a>静态代理类测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.vincent.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.vincent.proxy.staticproxy.Cat;</span><br><span class="line"><span class="keyword">import</span> org.vincent.proxy.staticproxy.FeederProxy;</span><br><span class="line"><span class="keyword">import</span> org.vincent.proxy.staticproxy.Lion;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> PengRong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@package</span> org.vincent.proxy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/12/15 - 18:31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ProjectName</span> JavaAopLearning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 静态代理类测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">staticProxyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Lion lion = <span class="keyword">new</span> Lion();</span><br><span class="line">    lion.setName(<span class="string">"狮子 小王"</span>);</span><br><span class="line">    lion.setRunningSpeed(<span class="number">100</span>);        <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * new 静态代理类，静态代理类在编译前已经创建好了，和动态代理的最大区别点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Cat proxy = <span class="keyword">new</span> FeederProxy(lion);</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">" -- "</span> + proxy.eatFood(<span class="string">"水牛"</span>));</span><br><span class="line">    proxy.running();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态代理很好的诠释了代理设计模式，代理模式最主要的就是有一个公共接口（Cat），一个委托类（Lion），一个代理类（FeederProxy）,代理类持有委托类的实例，代为执行具体类实例方法。 上面说到，代理模式就是在访问实际对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。这里的间接性就是指客户端不直接调用实际对象的方法，客户端依赖公共接口并使用代理类。 那么我们在代理过程中就可以加上一些其他用途。 就这个例子来说在 eatFood方法调用中，代理类在调用具体实现类之前添加<code>System.out.println(&quot;proxy Lion exec eatFood &quot;);</code>语句 就是添加间接性带来的收益。代理类存在的意义是为了增加一些公共的逻辑代码。</p><h2 id="动态代理类-基于接口实现"><a href="#动态代理类-基于接口实现" class="headerlink" title="动态代理类(基于接口实现)"></a>动态代理类(基于接口实现)</h2><p>静态代理是代理类在代码运行前已经创建好，并生成class文件；动态代理类 是代理类在程序运行时创建的代理模式。<br>动态代理类的代理类并不是在Java代码中定义的，而是在运行时根据我们在Java代码中的“指示”动态生成的。相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。 想想你有100个静态代理类，现在有一个需求，每个代理类都需要新增一个处理逻辑，你需要打开100个代理类在每个代理方法里面新增处理逻辑吗？ 有或者代理类有5个方法，每个方法都需要新增一个处理逻辑， 你需要在每个方法都手动新增处理逻辑吗？ 想想就挺无趣的。动态代理类帮你一键搞定。</p><h3 id="动态代理类涉及角色"><a href="#动态代理类涉及角色" class="headerlink" title="动态代理类涉及角色"></a>动态代理类涉及角色</h3><ul><li>委托类和代理类实现的公共接口(Person.java)</li><li>实现公共接口的具体委托类(SoftwareEngineer.java)</li><li>InvocationHandler接口被Proxy类回调处理，一般实现 InvocationHandler 接口的类具有委托类引用，接口方法 invoke 中添加公共代码并调用委托类的接口方法。(PersonInvocationHandler.java)</li><li>JDK提供生成动态代理类的核心类Proxy (JDK 提供的Proxy.java)</li></ul><h3 id="基于JDK技术-动态代理类技术核心-Proxy类和一个-InvocationHandler-接口"><a href="#基于JDK技术-动态代理类技术核心-Proxy类和一个-InvocationHandler-接口" class="headerlink" title="基于JDK技术 动态代理类技术核心 Proxy类和一个 InvocationHandler 接口"></a>基于JDK技术 动态代理类技术核心 Proxy类和一个 InvocationHandler 接口</h3><p>java的java.lang.reflect包下提供了Proxy类和一个 InvocationHandler 接口，这个类Proxy定义了生成JDK动态代理类的方法 <code>getProxyClass(ClassLoader loader,Class&lt;?&gt;... interfaces)</code>生成动态代理类,返回class实例代表一个class文件。可以保存该 class 文件查看jdk生成的代理类文件长什么样<br>该生成的动态代理类继承Proxy类，(重要特性) ，并实现公共接口。<br>InvocationHandler这个接口 是被动态代理类回调的接口，我们所有需要增加的针对委托类的统一处理逻辑都增加到invoke 方法里面在调用委托类接口方法之前或之后 结束战斗。</p><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><h5 id="公共接口"><a href="#公共接口" class="headerlink" title="公共接口"></a>公共接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.vincent.proxy.dynamicproxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by PengRong on 2018/12/25. 创建Person 接口 用于定义 委托类和代理类之间的约束行为</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name 人名</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> dst  工作目的地</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">goWorking</span><span class="params">(String name, String dst)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取名称</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置名称</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="具体实现类，等下被委托，被代理的类-SoftwareEngineer-java"><a href="#具体实现类，等下被委托，被代理的类-SoftwareEngineer-java" class="headerlink" title="具体实现类，等下被委托，被代理的类 SoftwareEngineer.java"></a>具体实现类，等下被委托，被代理的类 SoftwareEngineer.java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.vincent.proxy.dynamicproxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by PengRong on 2018/12/25. 动态代理委托类实现， 实现接口 Person。 被动态生成的代理类代理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoftwareEngineer</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SoftwareEngineer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SoftwareEngineer</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goWorking</span><span class="params">(String name, String dst)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"name ="</span> + name + <span class="string">" ， 去 "</span> + dst + <span class="string">" 工作"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="InvocationHandler-接口实现-PersonInvocationHandler-java"><a href="#InvocationHandler-接口实现-PersonInvocationHandler-java" class="headerlink" title="InvocationHandler 接口实现 PersonInvocationHandler.java"></a>InvocationHandler 接口实现 PersonInvocationHandler.java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.vincent.proxy.dynamicproxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by PengRong on 2018/12/25. PersonInvocationHandler 类 实现InvocationHandler接口，这个类中持有一个被代理对象(委托类)的实例target。该类别JDK</span></span><br><span class="line"><span class="comment"> * Proxy类回调 InvocationHandler 接口中有一个invoke方法，当一个代理实例的方法被调用时，代理方法将被编码并分发到</span></span><br><span class="line"><span class="comment"> * InvocationHandler接口的invoke方法执行。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonInvocationHandler</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 被代理对象引用，invoke 方法里面method 需要使用这个 被代理对象</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  T target;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PersonInvocationHandler</span><span class="params">(T target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 在</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> proxy  代表动态生成的 动态代理 对象实例</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> method 代表被调用委托类的接口方法，和生成的代理类实例调用的接口方法是一致的，它对应的Method 实例</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> args   代表调用接口方法对应的Object参数数组，如果接口是无参，则为null； 对于原始数据类型返回的他的包装类型。</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;        <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 在转调具体目标对象之前，可以执行一些功能处理</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    System.out.println(</span><br><span class="line">        <span class="string">"被动态代理类回调执行, 代理类 proxyClass ="</span> + proxy.getClass() + <span class="string">" 方法名: "</span> + method.getName()</span><br><span class="line">            + <span class="string">"方法. 方法返回类型："</span> + method.getReturnType()</span><br><span class="line">            + <span class="string">" 接口方法入参数组: "</span> + (args == <span class="keyword">null</span> ? <span class="string">"null"</span> : Arrays.toString(args)));        <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理过程中插入监测方法,计算该方法耗时</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MonitorUtil.start();</span><br><span class="line">    Thread.sleep(<span class="number">1</span>);        <span class="comment">/** 调用呗代理对象的真实方法，*/</span></span><br><span class="line">    Object result = method.invoke(target, args);</span><br><span class="line">    MonitorUtil.finish(method.getName());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="PersonInvocationHandler-invoke-方法中添加的公共代码，这里简单以统计方法执行时间为逻辑"><a href="#PersonInvocationHandler-invoke-方法中添加的公共代码，这里简单以统计方法执行时间为逻辑" class="headerlink" title="PersonInvocationHandler invoke 方法中添加的公共代码，这里简单以统计方法执行时间为逻辑"></a>PersonInvocationHandler invoke 方法中添加的公共代码，这里简单以统计方法执行时间为逻辑</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.vincent.proxy.dynamicproxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by PengRong on 2018/12/25. 方法用时监控类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Long&gt; tl = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    tl.set(System.currentTimeMillis());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 结束时打印耗时</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> methodName 方法名</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(String methodName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> finishTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(methodName + <span class="string">"方法执行耗时"</span> + (finishTime - tl.get()) + <span class="string">"ms"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="最后的是-怎么创建代理类"><a href="#最后的是-怎么创建代理类" class="headerlink" title="最后的是 怎么创建代理类"></a>最后的是 怎么创建代理类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.vincent.proxy.jdkdynamicProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> org.vincent.proxy.dynamicproxy.Person;</span><br><span class="line"><span class="keyword">import</span> org.vincent.proxy.dynamicproxy.PersonInvocationHandler;</span><br><span class="line"><span class="keyword">import</span> org.vincent.proxy.dynamicproxy.SoftwareEngineer;</span><br><span class="line"><span class="keyword">import</span> sun.misc.ProxyGenerator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态代理类测试 Created by PengRong on 2018/12/25.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicProxyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;        <span class="comment">// 打开保存JDK动态代理生成的类文件</span></span><br><span class="line">    saveGeneratedJdkProxyFiles();        <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第一种方法: 通过 Proxy.newProxyInstance 方法 获取代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out</span><br><span class="line">        .println(<span class="string">"-------------------第一种创建代理类方法--------------"</span>);        <span class="comment">//创建一个实例对象，这个对象是被代理的对象，委托类</span></span><br><span class="line">    Person person = <span class="keyword">new</span> SoftwareEngineer(</span><br><span class="line">        <span class="string">"Vincent"</span>);        <span class="comment">//创建一个与代理类相关联的InvocationHandler,每一个代理类都有一个关联的 InvocationHandler，并将代理类引用传递进去</span></span><br><span class="line">    InvocationHandler Handler = <span class="keyword">new</span> PersonInvocationHandler&lt;&gt;(</span><br><span class="line">        person);        <span class="comment">//创建一个 代理对象 personProxy 来代理 person，创建的代理对象的每个执行方法都会被替换执行Invocation接口中的invoke方法</span></span><br><span class="line">    Person personProxy = (Person) Proxy</span><br><span class="line">        .newProxyInstance(Person.class.getClassLoader(), new Class&lt;?&gt;[]&#123;Person.class&#125;,</span><br><span class="line">            Handler);        <span class="comment">/** 代理类信息 */</span></span><br><span class="line">    System.out.println(</span><br><span class="line">        <span class="string">"package = "</span> + personProxy.getClass().getPackage() + <span class="string">" SimpleName = "</span> + personProxy</span><br><span class="line">            .getClass().getSimpleName() + <span class="string">" name ="</span> + personProxy.getClass().getName()</span><br><span class="line">            + <span class="string">" CanonicalName = "</span> + <span class="string">""</span> + personProxy.getClass().getCanonicalName()</span><br><span class="line">            + <span class="string">" 实现的接口 Interfaces = "</span> + Arrays.toString(personProxy.getClass().getInterfaces())</span><br><span class="line">            + <span class="string">" superClass = "</span> + personProxy.getClass().getSuperclass() + <span class="string">" methods ="</span> + Arrays</span><br><span class="line">            .toString(personProxy.getClass().getMethods()));        <span class="comment">// 通过 代理类 执行 委托类的代码逻辑</span></span><br><span class="line">    personProxy.goWorking(personProxy.getName(), <span class="string">"深圳"</span>);</span><br><span class="line">    System.out.println(<span class="string">"-------------------第二种创建代理类方法--------------"</span>);        <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  动态代理对象步骤</span></span><br><span class="line"><span class="comment">     *      1、 创建一个与代理对象相关联的 InvocationHandler，以及真实的委托类实例</span></span><br><span class="line"><span class="comment">     *      2、Proxy类的getProxyClass静态方法生成一个动态代理类stuProxyClass，该类继承Proxy类，实现 Person.java接口；JDK动态代理的特点是代理类必须继承Proxy类</span></span><br><span class="line"><span class="comment">     *      3、通过代理类 proxyClass 获得他的带InvocationHandler 接口的构造函数 ProxyConstructor</span></span><br><span class="line"><span class="comment">     *      4、通过 构造函数实例 ProxyConstructor 实例化一个代理对象，并将  InvocationHandler 接口实例传递给代理类。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 1、创建 InvocationHandler 实例并设置代理的目标类对象</span></span><br><span class="line">    Person persontwo = <span class="keyword">new</span> SoftwareEngineer(<span class="string">"Vincent"</span>);</span><br><span class="line">    InvocationHandler Handlertwo = <span class="keyword">new</span> PersonInvocationHandler&lt;&gt;(</span><br><span class="line">        persontwo);        <span class="comment">// 2 创建代理类,是一个字节码文件, 把 proxyClass 保存起来就能看到 他继承Proxy 类，实现Person接口</span></span><br><span class="line">    Class&lt;?&gt; proxyClass = Proxy.getProxyClass(Person<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(),</span></span><br><span class="line">        new Class&lt;?&gt;[]&#123;Person.class&#125;);        /** 代理类信息 */</span><br><span class="line">    System.out.println(</span><br><span class="line">        <span class="string">"package = "</span> + proxyClass.getPackage() + <span class="string">" SimpleName = "</span> + proxyClass.getSimpleName()</span><br><span class="line">            + <span class="string">" name ="</span> + proxyClass.getName() + <span class="string">" CanonicalName = "</span> + <span class="string">""</span> + proxyClass</span><br><span class="line">            .getCanonicalName() + <span class="string">" 实现的接口 Interfaces = "</span> + Arrays</span><br><span class="line">            .toString(proxyClass.getInterfaces()) + <span class="string">" superClass = "</span> + proxyClass.getSuperclass()</span><br><span class="line">            + <span class="string">" methods ="</span> + Arrays.toString(proxyClass</span><br><span class="line">            .getMethods()));        <span class="comment">// 3、  通过 proxyClass 获得 一个带有InvocationHandler参数的构造器constructor</span></span><br><span class="line">    Constructor&lt;?&gt; ProxyConstructor = proxyClass</span><br><span class="line">        .getConstructor(InvocationHandler<span class="class">.<span class="keyword">class</span>)</span>;        <span class="comment">// 4、通过构造器创建一个  动态代理类 实例</span></span><br><span class="line">    Person stuProxy = (Person) ProxyConstructor.newInstance(Handlertwo);        <span class="comment">/** 检测生成的类是否是代理类 */</span></span><br><span class="line">    System.out.println(<span class="string">"stuProxy isProxy "</span> + Proxy</span><br><span class="line">        .isProxyClass(stuProxy.getClass()));        <span class="comment">/** 获取 代理类关联的 InvocationHandler 是哪个*/</span></span><br><span class="line">    InvocationHandler handlerObject = Proxy.getInvocationHandler(stuProxy);</span><br><span class="line">    System.out.println(handlerObject.getClass().getName());</span><br><span class="line">    stuProxy.goWorking(stuProxy.getName(), <span class="string">"广州"</span>);        <span class="comment">// 保存代理類</span></span><br><span class="line">    saveClass(<span class="string">"$PersonProxy0"</span>, proxyClass.getInterfaces(), <span class="string">"D:/123/"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 生成代理类 class 并保持到文件中</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> className  生成的代理类名称</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> interfaces 代理类需要实现的接口</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> pathdir    代理类保存的目录路径,以目录分隔符结尾</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">saveClass</span><span class="params">(String className, Class&lt;?&gt;[] interfaces, String pathdir)</span> </span>&#123;        <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 第一个参数是 代理类 名 。</span></span><br><span class="line"><span class="comment">   * 第二个参数是 代理类需要实现的接口</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="keyword">byte</span>[] classFile = ProxyGenerator.generateProxyClass(className, interfaces);        <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果目录不存在就新建所有子目录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Path path1 = Paths.get(pathdir);</span><br><span class="line">    <span class="keyword">if</span> (!path1.toFile().exists()) &#123;</span><br><span class="line">      path1.toFile().mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line">    String path = pathdir + className + <span class="string">".class"</span>;</span><br><span class="line">    <span class="keyword">try</span> (FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(path)) &#123;</span><br><span class="line">      fos.write(classFile);</span><br><span class="line">      fos.flush();</span><br><span class="line">      System.out.println(<span class="string">"代理类class文件写入成功"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      System.out.println(<span class="string">"写文件错误"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置保存Java动态代理生成的类文件。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">saveGeneratedJdkProxyFiles</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Field field = System.class.getDeclaredField("props");</span><br><span class="line">    field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Properties props = (Properties) field.get(<span class="keyword">null</span>);</span><br><span class="line">    props.put(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解析JDK生成的动态代理类"><a href="#解析JDK生成的动态代理类" class="headerlink" title="解析JDK生成的动态代理类"></a>解析JDK生成的动态代理类</h4><p>saveGeneratedJdkProxyFiles方法 打开了存储jdk生成的动态代理类 以 接口方法 goWorking 为例讲解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//</span></span><br><span class="line"><span class="keyword">package</span> com.sun.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"><span class="keyword">import</span> org.vincent.proxy.dynamicproxy.Person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m4;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m5;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">super</span>(var1);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> ((Boolean) <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;)).booleanValue();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">      <span class="keyword">throw</span> var3;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String var1)</span> <span class="keyword">throws</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m4, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">      <span class="keyword">throw</span> var3;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getName</span><span class="params">()</span> <span class="keyword">throws</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (String) <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[]) <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">      <span class="keyword">throw</span> var2;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (String) <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[]) <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">      <span class="keyword">throw</span> var2;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 对接口  goWorking 的调用 转变成   super.h.invoke(this, m5, new Object[]&#123;var1, var2&#125;); 调用。 h</span></span><br><span class="line"><span class="comment">   * 就是Proxy.java类的一个 InvocationHandler 接口 属性， 我们在创建 动态代理类实例时候都必须 传一个 InvocationHandler 接口的实例过去。</span></span><br><span class="line"><span class="comment">   * 这里就是刚才我们定义的 PersonInvocationHandler 。 回到过后是不是就回到了 PersonInvocationHandler.invoke方法里面，所以</span></span><br><span class="line"><span class="comment">   * PersonInvocationHandler 是我们生成的动态代理类的拦截器，拦截所有方法调用。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">goWorking</span><span class="params">(String var1, String var2)</span> <span class="keyword">throws</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m5, <span class="keyword">new</span> Object[]&#123;var1, var2&#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException | Error var4) &#123;</span><br><span class="line">      <span class="keyword">throw</span> var4;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var5) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var5);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> ((Integer) <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[]) <span class="keyword">null</span>)).intValue();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">      <span class="keyword">throw</span> var2;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 静态代码块，根据动态代理实现的公共接口类接口方法 获取到所有接口方法 的 Method 实例*/</span></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      m1 = Class.forName(<span class="string">"java.lang.Object"</span>)</span><br><span class="line">          .getMethod(<span class="string">"equals"</span>, <span class="keyword">new</span> Class[]&#123;Class.forName(<span class="string">"java.lang.Object"</span>)&#125;);</span><br><span class="line">      m4 = Class.forName(<span class="string">"org.vincent.proxy.dynamicproxy.Person"</span>)</span><br><span class="line">          .getMethod(<span class="string">"setName"</span>, <span class="keyword">new</span> Class[]&#123;Class.forName(<span class="string">"java.lang.String"</span>)&#125;);</span><br><span class="line">      m3 = Class.forName(<span class="string">"org.vincent.proxy.dynamicproxy.Person"</span>)</span><br><span class="line">          .getMethod(<span class="string">"getName"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">      m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">      m5 = Class.forName(<span class="string">"org.vincent.proxy.dynamicproxy.Person"</span>).getMethod(<span class="string">"goWorking"</span>,</span><br><span class="line">          <span class="keyword">new</span> Class[]&#123;Class.forName(<span class="string">"java.lang.String"</span>), Class.forName(<span class="string">"java.lang.String"</span>)&#125;);</span><br><span class="line">      m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Jdk为我们的生成了一个叫$Proxy0（这个名字后面的0是编号，有多个代理类会一次递增）的代理类，这个类文件时默认不会保存在文件，放在内存中的，我们在创建代理对象时，就是通过反射获得这个类的构造方法，然后创建代理对象实例。通过对这个生成的代理类源码的查看，我们很容易能看出，动态代理实现的具体过程。<br>我们可以对 InvocationHandler 看做一个中介类，中介类持有一个被代理对象，被Proxy类回调。在invoke方法中调用了被代理对象的相应方法。通过聚合方式持有被代理对象的引用，把客户端对invoke的调用最终都转为对被代理对象的调用。<br>客户端代码通过代理类引用调用接口方法时，通过代理类关联的中介类对象引用来调用中介类对象的invoke方法，从而达到代理执行被代理对象的方法。也就是说，动态代理Proxy类提供了模板实现，对外提供扩展点，外部通过实现InvocationHandler接口将被代理类纳入JDK代理类Proxy。</p><h4 id="一个典型的基于JDK动态代理创建对象过程可分为以下四个步骤："><a href="#一个典型的基于JDK动态代理创建对象过程可分为以下四个步骤：" class="headerlink" title="一个典型的基于JDK动态代理创建对象过程可分为以下四个步骤："></a>一个典型的基于JDK动态代理创建对象过程可分为以下四个步骤：</h4><ol><li>通过实现InvocationHandler接口创建自己的调用处理器 IvocationHandler handler = new InvocationHandlerImpl(…);</li><li>通过为Proxy类指定ClassLoader对象和一组interface代理类需要实现的接口，创建动态代理类类文件，默认JDK并不会保存这个文件到文件中；可以保存起来观察生成的代理类结构<code>Class clazz = Proxy.getProxyClass(classLoader,new Class[]{...});</code></li><li>通过上面新建的代理clazz的反射机制获取动态代理类的一个构造函数，其构造函数入参类型是调用处理器接口(<code>IvocationHandler</code>)类型 <code>Constructor constructor = clazz.getConstructor(new Class[]{InvocationHandler.class});</code></li><li>通过构造函数实例创建代理类实例，此时需将调用处理器对象作为参数被传入 Interface Proxy = (Interface)constructor.newInstance(new Object[] (handler)); 为了简化对象创建过程，Proxy类中的newInstance工具方法封装了2~4，只需两步即可完成代理对象的创建。</li></ol><h4 id="JDK动态代理特点总结"><a href="#JDK动态代理特点总结" class="headerlink" title="JDK动态代理特点总结"></a>JDK动态代理特点总结</h4><ul><li>生成的代理类：$Proxy0 extends Proxy implements Person，我们看到代理类继承了Proxy类，Java的继承机制决定了JDK动态代理类们无法实现对 类 的动态代理。所以也就决定了java动态代理只能对接口进行代理，</li><li>每个生成的动态代理实例都会关联一个调用处理器对象，可以通过 Proxy 提供的静态方法 getInvocationHandler 去获得代理类实例的调用处理器对象。在代理类实例上调用其代理的接口中所声明的方法时，这些方法最终都会由调用处理器的 invoke 方法执行</li><li>代理类的根类 java.lang.Object 中有三个方法也同样会被分派到调用处理器的 invoke 方法执行，它们是 hashCode，equals 和 toString，可能的原因有：一是因为这些方法为 public 且非 final 类型，能够被代理类覆盖； 二是因为这些方法往往呈现出一个类的某种特征属性，具有一定的区分度，所以为了保证代理类与委托类对外的一致性，这三个方法也应该被调用处理器分派到委托类执行。</li></ul><h4 id="JDK动态代理不足"><a href="#JDK动态代理不足" class="headerlink" title="JDK动态代理不足"></a>JDK动态代理不足</h4><p>JDK动态代理的代理类字节码在创建时，需要实现业务实现类所实现的接口作为参数。如果业务实现类是没有实现接口而是直接定义业务方法的话，就无法使用JDK动态代理了。(JDK动态代理重要特点是代理接口) 并且，如果业务实现类中新增了接口中没有的方法，这些方法是无法被代理的（因为无法被调用）。<br>动态代理只能对接口产生代理，不能对类产生代理</p><h3 id="基于CGlib-技术动态代理代理类实现-基于继承"><a href="#基于CGlib-技术动态代理代理类实现-基于继承" class="headerlink" title="基于CGlib 技术动态代理代理类实现 (基于继承)"></a>基于CGlib 技术动态代理代理类实现 (基于继承)</h3><p>Cglib是针对类来实现代理的，他的原理是对代理的目标类生成一个子类，并覆盖其中方法实现增强，因为底层是基于创建被代理类的一个子类，所以它避免了JDK动态代理类的缺陷。<br>但因为采用的是继承，所以不能对final修饰的类进行代理。final修饰的类不可继承。</p><h4 id="导入maven-依赖"><a href="#导入maven-依赖" class="headerlink" title="导入maven 依赖"></a>导入maven 依赖</h4><p>cglib 是基于asm 字节修改技术。导入 cglib 会间接导入 asm, ant, ant-launcher 三个jar 包。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- cglib 动态代理依赖 begin --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- cglib 动态代理依赖 stop --&gt;</span></span><br></pre></td></tr></table></figure><h4 id="业务类实现"><a href="#业务类实现" class="headerlink" title="业务类实现"></a>业务类实现</h4><p>cglib是针对类来实现代理的，原理是对指定的业务类生成他的一个子类，并覆盖其中的业务方法来实现代理。因为采用的是继承，所以不能对final修饰的类进行代理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.vincent.proxy.cglibproxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Package</span>: org.vincent.proxy.cglibproxy &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>： Cglib 代理模式中 被代理的委托类 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: lenovo &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Company</span>: PLCC &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Copyright</span>: Copyright (c) 2019 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: 1.0 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By: &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by lenovo on 2018/12/26-17:55 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"wang wang wang"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Dog .."</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法拦截器-实现-MethodInterceptor-接口"><a href="#方法拦截器-实现-MethodInterceptor-接口" class="headerlink" title="方法拦截器 实现 MethodInterceptor 接口"></a>方法拦截器 实现 MethodInterceptor 接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.vincent.proxy.cglibproxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Package</span>: org.vincent.proxy.cglibproxy &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>： Cglib 方法拦截器,不用依赖被代理业务类的引用。  &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: lenovo &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Company</span>: PLCC &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Copyright</span>: Copyright (c) 2019 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: 1.0 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By: &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by lenovo on 2018/12/26-17:56 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 用于生成 Cglib 动态代理类工具方法</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> target 代表需要 被代理的 委托类的 Class 对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">CglibProxyGeneratory</span><span class="params">(Class target)</span> </span>&#123;        <span class="comment">/** 创建cglib 代理类 start */</span></span><br><span class="line">    <span class="comment">// 创建加强器，用来创建动态代理类</span></span><br><span class="line">    Enhancer enhancer = <span class="keyword">new</span> Enhancer();        <span class="comment">// 为代理类指定需要代理的类，也即是父类</span></span><br><span class="line">    enhancer.setSuperclass(</span><br><span class="line">        target);        <span class="comment">// 设置方法拦截器回调引用，对于代理类上所有方法的调用，都会调用CallBack，而Callback则需要实现intercept() 方法进行拦截</span></span><br><span class="line">    enhancer.setCallback(<span class="keyword">this</span>);        <span class="comment">// 获取动态代理类对象并返回</span></span><br><span class="line">    <span class="keyword">return</span> enhancer.create();        <span class="comment">/** 创建cglib 代理类 end */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 功能主要是在调用业务类方法之前 之后添加统计时间的方法逻辑. intercept 因为  具有 MethodProxy proxy 参数的原因 不再需要代理类的引用对象了,直接通过proxy</span></span><br><span class="line"><span class="comment">   * 对象访问被代理对象的方法(这种方式更快)。 当然 也可以通过反射机制，通过 method 引用实例    Object result = method.invoke(target,</span></span><br><span class="line"><span class="comment">   * args); 形式反射调用被代理类方法， target 实例代表被代理类对象引用, 初始化 CglibMethodInterceptor 时候被赋值 。但是Cglib不推荐使用这种方式</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> obj    代表Cglib 生成的动态代理类 对象本身</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> method 代理类中被拦截的接口方法 Method 实例</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> args   接口方法参数</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> proxy  用于调用父类真正的业务类方法。可以直接调用被代理类接口方法</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"before"</span>);</span><br><span class="line">    MonitorUtil.start();</span><br><span class="line">    Object result = proxy</span><br><span class="line">        .invokeSuper(obj, args);        <span class="comment">//Object result = method.invoke(target, args);</span></span><br><span class="line">    System.out.println(<span class="string">"after"</span>);</span><br><span class="line">    MonitorUtil.finish(method.getName());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一个切面，用于在方法拦截器中intercept-方法中调用真正业务方法之前-之后处理逻辑"><a href="#一个切面，用于在方法拦截器中intercept-方法中调用真正业务方法之前-之后处理逻辑" class="headerlink" title="一个切面，用于在方法拦截器中intercept 方法中调用真正业务方法之前 之后处理逻辑"></a>一个切面，用于在方法拦截器中intercept 方法中调用真正业务方法之前 之后处理逻辑</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.vincent.proxy.cglibproxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by PengRong on 2018/12/25. 方法用时监控类,作为一个切面 ，具有两个方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Long&gt; tl = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    tl.set(System.currentTimeMillis());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 结束时打印耗时</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> methodName 方法名</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(String methodName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> finishTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(methodName + <span class="string">"方法执行耗时"</span> + (finishTime - tl.get()) + <span class="string">"ms"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Cglib测试类"><a href="#Cglib测试类" class="headerlink" title="Cglib测试类"></a>Cglib测试类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.vincent.proxy.cglibproxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.core.DebuggingClassWriter;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Package</span>: org.vincent.proxy.cglibproxy &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>： TODO &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: lenovo &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Company</span>: PLCC &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Copyright</span>: Copyright (c) 2019 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: 1.0 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By: &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by lenovo on 2018/12/26-18:05 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCglib</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(System.getProperty(<span class="string">"user.dir"</span>));        <span class="comment">/** 开启 保存cglib生成的动态代理类类文件*/</span></span><br><span class="line">    saveGeneratedCGlibProxyFiles(</span><br><span class="line">        System.getProperty(<span class="string">"user.dir"</span>));        <span class="comment">/** 第一种方法: 创建cglib 代理类 start */</span></span><br><span class="line">    <span class="comment">// 创建加强器，用来创建动态代理类</span></span><br><span class="line">    Enhancer enhancer = <span class="keyword">new</span> Enhancer();        <span class="comment">// 为代理类指定需要代理的类，也即是父类</span></span><br><span class="line">    enhancer.setSuperclass(Dog<span class="class">.<span class="keyword">class</span>)</span>;        <span class="comment">// new 一个新的方法拦截器</span></span><br><span class="line">    CglibMethodInterceptor cglibMethodInterceptor = <span class="keyword">new</span> CglibMethodInterceptor();        <span class="comment">// 设置方法拦截器回调引用，对于代理类上所有方法的调用，都会调用CallBack，而Callback则需要实现intercept() 方法进行拦截</span></span><br><span class="line">    enhancer.setCallback(cglibMethodInterceptor);        <span class="comment">// 获取动态代理类对象并返回</span></span><br><span class="line">    Dog dog = (Dog) enhancer.create();        <span class="comment">/** 创建cglib 代理类 end */</span></span><br><span class="line">    System.out</span><br><span class="line">        .println(dog.call());        <span class="comment">// 对于上面这几步，可以新增一个工具方法 放置在 CglibMethodInterceptor 里面；也就有了第二种方法</span></span><br><span class="line">    <span class="comment">// new 一个新的方法拦截器，该拦截器还顺带一个用于创建代理类的工具方法。看起来简单很多</span></span><br><span class="line">    cglibMethodInterceptor = <span class="keyword">new</span> CglibMethodInterceptor();</span><br><span class="line">    dog = (Dog) cglibMethodInterceptor.CglibProxyGeneratory(Dog<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    System.out.println(dog.call());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置保存Cglib代理生成的类文件。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveGeneratedCGlibProxyFiles</span><span class="params">(String dir)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Field field = System.class.getDeclaredField("props");</span><br><span class="line">    field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Properties props = (Properties) field.get(<span class="keyword">null</span>);</span><br><span class="line">    System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, dir);<span class="comment">//dir为保存文件路径</span></span><br><span class="line">    props.put(<span class="string">"net.sf.cglib.core.DebuggingClassWriter.traceEnabled"</span>, <span class="string">"true"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Cglib-总结"><a href="#Cglib-总结" class="headerlink" title="Cglib 总结"></a>Cglib 总结</h4><ul><li>CGlib可以传入接口也可以传入普通的类，接口使用实现的方式,普通类使用会使用继承的方式生成代理类.</li><li>由于是继承方式,如果是 static方法,private方法,final方法等描述的方法是不能被代理的</li><li>做了方法访问优化，使用建立方法索引的方式避免了传统JDK动态代理需要通过Method方法反射调用.</li><li>提供callback 和filter设计，可以灵活地给不同的方法绑定不同的callback。编码更方便灵活。</li><li>CGLIB会默认代理Object中equals,toString,hashCode,clone等方法。比JDK代理多了clone。</li></ul><h2 id="静态代理-基于JDK动态代理-基于Cglib-动态代理"><a href="#静态代理-基于JDK动态代理-基于Cglib-动态代理" class="headerlink" title="静态代理 基于JDK动态代理 基于Cglib 动态代理"></a>静态代理 基于JDK动态代理 基于Cglib 动态代理</h2><p>静态代理是通过在代码中显式编码定义一个业务实现类的代理类，在代理类中对同名的业务方法进行包装，用户通过代理类调用被包装过的业务方法；<br>JDK动态代理是通过接口中的方法名，在动态生成的代理类中调用业务实现类的同名方法；<br>CGlib动态代理是通过继承业务类，生成的动态代理类是业务类的子类，通过重写业务方法进行代理；<br>静态代理在编译时产生class字节码文件，可以直接使用，效率高。动态代理必须实现InvocationHandler接口，通过invoke调用被委托类接口方法是通过反射方式，比较消耗系统性能，但可以减少代理类的数量，使用更灵活。 cglib代理无需实现接口，通过生成类字节码实现代理，比反射稍快，不存在性能问题，但cglib会继承目标对象，需要重写方法，所以目标对象不能为final类。</p><h2 id="AOP-实现案例"><a href="#AOP-实现案例" class="headerlink" title="AOP 实现案例"></a>AOP 实现案例</h2><p>AOP的源码中用到了两种动态代理来实现拦截切入功能：jdk动态代理和cglib动态代理。两种方法同时存在，各有优劣。 jdk动态代理是由java内部的反射机制来实现的，cglib动态代理底层则是借助asm来实现的。 总的来说，反射机制在生成类的过程中比较高效，执行时候通过反射调用委托类接口方法比较慢；而asm在生成类之后的相关代理类执行过程中比较高效（可以通过将asm生成的类进行缓存，这样解决asm生成类过程低效问题）。 还有一点必须注意：jdk动态代理的应用前提，必须是委托类基于统一的接口。如果没有上述前提，jdk动态代理不能应用。 由此可以看出，jdk动态代理有一定的局限性，cglib这种第三方类库实现的动态代理应用更加广泛，且在效率上更有优势。<br>实现AOP关键特点是定义好两个角色 切点 和 切面 。 代理模式中被代理类 委托类处于切点角色，需要添加的其他比如 校验逻辑，事务，审计逻辑 属于非功能实现逻辑通过 切面类定义的方法插入进去。</p><h3 id="JDK动态代理-aop-实现方式"><a href="#JDK动态代理-aop-实现方式" class="headerlink" title="JDK动态代理 aop 实现方式"></a>JDK动态代理 aop 实现方式</h3><h4 id="定义切面接口，完成将通用公共方法注入到被代理类接口调用处理中"><a href="#定义切面接口，完成将通用公共方法注入到被代理类接口调用处理中" class="headerlink" title="定义切面接口，完成将通用公共方法注入到被代理类接口调用处理中"></a>定义切面接口，完成将通用公共方法注入到被代理类接口调用处理中</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.vincent.aop.dynamicproxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Package</span>: org.vincent.aop.dynamicproxy &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>： 定义切面接口，切面接口定义了两个切面方法，分别在切点接口方法执行前和执行后执行 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: lenovo &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Company</span>: PLCC &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Copyright</span>: Copyright (c) 2019 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: 1.0 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By: &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by lenovo on 2018/12/26 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 在切点接口方法执行之前执行</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> args 切点参数列表</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">startTransaction</span><span class="params">(Object... args)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 在切点接口方法执行之后执行</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">endTrasaction</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义切面实现类"><a href="#定义切面实现类" class="headerlink" title="定义切面实现类"></a>定义切面实现类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.vincent.aop.dynamicproxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Package</span>: org.vincent.aop.dynamicproxy &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>： 改类作为AOP 模型中切面角色类， 实现切面接口，切面接口定义了两个切面方法，分别在切点接口方法执行前和执行后执行 。 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: lenovo &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Company</span>: PLCC &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Copyright</span>: Copyright (c) 2019 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: 1.0 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By: &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by lenovo on 2018/12/26 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomAspect</span> <span class="keyword">implements</span> <span class="title">IAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 对参数 做判空处理</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> args 切点参数列表</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startTransaction</span><span class="params">(Object... args)</span> </span>&#123;</span><br><span class="line">    Objects.nonNull(args);</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (Object temp : args) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Objects.isNull(temp)) &#123;</span><br><span class="line">        result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endTrasaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"I get datasource here and end transaction"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义切点角色接口-因为是基于JDK实现的Aop-，所以委托类需要基于接口实现。"><a href="#定义切点角色接口-因为是基于JDK实现的Aop-，所以委托类需要基于接口实现。" class="headerlink" title="定义切点角色接口 因为是基于JDK实现的Aop ，所以委托类需要基于接口实现。"></a>定义切点角色接口 因为是基于JDK实现的Aop ，所以委托类需要基于接口实现。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.vincent.aop.dynamicproxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Package</span>: org.vincent.aop.dynamicproxy &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>： AOP基于动态代理 实现  &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: lenovo &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Company</span>: PLCC &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Copyright</span>: Copyright (c) 2019 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: 1.0 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By: &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by lenovo on 2018/12/26 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="委托类实现"><a href="#委托类实现" class="headerlink" title="委托类实现"></a>委托类实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.vincent.aop.dynamicproxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Package</span>: org.vincent.aop.dynamicproxy &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>： UserService接口实现类UserServiceImpl 该类 作为AOP中切点角色，切面定义的方法插入到切点的接口方法 执行前和执行后执行。 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: lenovo &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Company</span>: PLCC &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Copyright</span>: Copyright (c) 2019 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: 1.0 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By: &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by lenovo on 2018/12/26 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">IUserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"save user[username="</span> + username + <span class="string">",password="</span> + password + <span class="string">"]"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JDK动态代理生成器工具类"><a href="#JDK动态代理生成器工具类" class="headerlink" title="JDK动态代理生成器工具类"></a>JDK动态代理生成器工具类</h4><p>可以看到 generatorJDKProxy 方法入参只有两个参数 一个切点接口引用，一个切面接口引用；在InvocationHandler 内部类中可以完整看到切面类方法是怎么影响切点代码执行逻辑的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.vincent.aop.dynamicproxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Package</span>: org.vincent.aop.dynamicproxy &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>： JDK动态代理类生成器 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: lenovo &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Company</span>: PLCC &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Copyright</span>: Copyright (c) 2019 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: 1.0 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By: &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by lenovo on 2018/12/26-16:48 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKDynamicProxyGenerator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> targetPoint 需要被代理的委托类对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> aspect      切面对象,该对象方法将在切点方法之前或之后执行</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">generatorJDKProxy</span><span class="params">(IUserService targetPoint, <span class="keyword">final</span> IAspect aspect)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(                <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *   委托类使用的类加载器</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        targetPoint.getClass().getClassLoader(),                <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 委托类实现的接口</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        targetPoint.getClass().getInterfaces(),                <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 生成的动态代理类关联的 执行处理器，代理我们的业务逻辑被生成的动态代理类回调</span></span><br><span class="line"><span class="comment">         * 具体逻辑代码执行,返回值为方法执行结果, 在aop模型中，委托类的接口方法称为切点。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">              <span class="keyword">throws</span> Throwable </span>&#123;                        <span class="comment">// 执行切面方法,对入参进行校验</span></span><br><span class="line">            <span class="keyword">boolean</span> prepareAction = aspect.startTransaction(args);</span><br><span class="line">            <span class="keyword">if</span> (prepareAction) &#123;                           <span class="comment">// 具体逻辑代码执行,返回值为方法执行结果</span></span><br><span class="line">              Object result = method.invoke(targetPoint, args);</span><br><span class="line">              aspect.endTrasaction();</span><br><span class="line">              <span class="keyword">return</span> result;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"args: "</span> + Arrays.toString(args) + <span class="string">"不能为null "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.vincent.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.vincent.aop.dynamicproxy.CustomAspect;</span><br><span class="line"><span class="keyword">import</span> org.vincent.aop.dynamicproxy.IUserService;</span><br><span class="line"><span class="keyword">import</span> org.vincent.aop.dynamicproxy.JDKDynamicProxyGenerator;</span><br><span class="line"><span class="keyword">import</span> org.vincent.aop.dynamicproxy.UserServiceImpl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Package</span>: org.vincent &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>： 基于动态代理类AOP测试案例 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: lenovo &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Company</span>: PLCC &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Copyright</span>: Copyright (c) 2019 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: 1.0 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By: &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by lenovo on 2018/12/26-16:56 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testAopJDKProxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJDKProxy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"无代理前 调用方法 userService.saveUser 输出......"</span>);</span><br><span class="line">    IUserService userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">    userService.saveUser(<span class="string">"zby"</span>, <span class="string">"1234567890"</span>);</span><br><span class="line">    System.out.println(<span class="string">"有代理后AOP 是怎么样的？ Proxy......"</span>);</span><br><span class="line">    IUserService proxyUserService = (IUserService) JDKDynamicProxyGenerator</span><br><span class="line">        .generatorJDKProxy(userService, <span class="keyword">new</span> CustomAspect());</span><br><span class="line">    proxyUserService.saveUser(<span class="string">"zby"</span>, <span class="string">"1234567890"</span>);        <span class="comment">/** 制造异常,两个入参都是null   */</span></span><br><span class="line">    proxyUserService.saveUser(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Cglib-aop-实现方式"><a href="#Cglib-aop-实现方式" class="headerlink" title="Cglib aop 实现方式"></a>Cglib aop 实现方式</h3><h4 id="定义切面接口"><a href="#定义切面接口" class="headerlink" title="定义切面接口"></a>定义切面接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.vincent.aop.cglib;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Package</span>: org.vincent.aop.dynamicproxy &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>： 定义切面接口，切面接口定义了两个切面方法，分别在切点接口方法执行前和执行后执行 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: lenovo &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Company</span>: PLCC &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Copyright</span>: Copyright (c) 2019 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: 1.0 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By: &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by lenovo on 2018/12/26 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 在切点接口方法执行之前执行</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">startTransaction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 在切点接口方法执行之后执行</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">endTrasaction</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="切面实现"><a href="#切面实现" class="headerlink" title="切面实现"></a>切面实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.vincent.aop.cglib;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Package</span>: org.vincent.aop.dynamicproxy &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>： 改类作为AOP 模型中切面角色类， 实现切面接口，切面接口定义了两个切面方法，分别在切点接口方法执行前和执行后执行 。 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: lenovo &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Company</span>: PLCC &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Copyright</span>: Copyright (c) 2019 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: 1.0 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By: &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by lenovo on 2018/12/26 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomAspect</span> <span class="keyword">implements</span> <span class="title">IAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"cglib. I get datasource here and start transaction"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endTrasaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"cglib I get datasource here and end transaction"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Cglib-是基于类实现的动态代理即业务类只需要实现类即可，不用强制必须实现某个接口为了突出这个优点这里没有实现接口"><a href="#Cglib-是基于类实现的动态代理即业务类只需要实现类即可，不用强制必须实现某个接口为了突出这个优点这里没有实现接口" class="headerlink" title="Cglib 是基于类实现的动态代理即业务类只需要实现类即可，不用强制必须实现某个接口为了突出这个优点这里没有实现接口"></a>Cglib 是基于类实现的动态代理即业务类只需要实现类即可，不用强制必须实现某个接口为了突出这个优点这里没有实现接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.vincent.aop.cglib;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Package</span>: org.vincent.aop.dynamicproxy &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>： 业务实现类UserServiceImpl 该类 作为AOP中切点角色，切面定义的方法插入到切点的接口方法 执行前和执行后执行。 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: lenovo &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Company</span>: PLCC &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Copyright</span>: Copyright (c) 2019 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: 1.0 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By: &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by lenovo on 2018/12/26 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"cglib save user[username="</span> + username + <span class="string">",password="</span> + password + <span class="string">"]"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Cglib-动态代理生成器工具类"><a href="#Cglib-动态代理生成器工具类" class="headerlink" title="Cglib 动态代理生成器工具类"></a>Cglib 动态代理生成器工具类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.vincent.aop.cglib;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Package</span>: org.vincent.aop.cglib &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>： 基于Cglib代理类生成器工具类 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: lenovo &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Company</span>: PLCC &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Copyright</span>: Copyright (c) 2019 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: 1.0 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By: &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by lenovo on 2018/12/26-17:04 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxyGenerator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> target 需要被代理的委托类对象，Cglib需要继承该类生成子类</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> aspect 切面对象,改对象方法将在切点方法之前或之后执行</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">generatorCglibProxy</span><span class="params">(<span class="keyword">final</span> Object target,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> IAspect aspect)</span> </span>&#123;        <span class="comment">//3.1 new Enhancer</span></span><br><span class="line">    Enhancer enhancer = <span class="keyword">new</span> Enhancer();        <span class="comment">//3.2 设置需要代理的父类</span></span><br><span class="line">    enhancer.setSuperclass(target.getClass());        <span class="comment">//3.3 设置回调</span></span><br><span class="line">    enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> Throwable </span>&#123;                <span class="comment">// 执行切面方法</span></span><br><span class="line">        aspect.startTransaction();                <span class="comment">// 具体逻辑代码执行,返回值为方法执行结果</span></span><br><span class="line">        Object result = methodProxy.invokeSuper(proxy, args);                <span class="comment">// 执行切面方法</span></span><br><span class="line">        aspect.endTrasaction();                <span class="comment">// 返回方法执行结果</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);        <span class="comment">// 3.4 创建代理对象</span></span><br><span class="line">    <span class="keyword">return</span> enhancer.create();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试类-1"><a href="#测试类-1" class="headerlink" title="测试类"></a>测试类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.vincent.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.vincent.aop.cglib.CglibProxyGenerator;</span><br><span class="line"><span class="keyword">import</span> org.vincent.aop.cglib.CustomAspect;</span><br><span class="line"><span class="keyword">import</span> org.vincent.aop.cglib.UserServiceImpl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Package</span>: org.vincent &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>： 基于动态代理类AOP测试案例 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: lenovo &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Company</span>: PLCC &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Copyright</span>: Copyright (c) 2019 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: 1.0 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By: &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by lenovo on 2018/12/26-16:56 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testAopCglibKProxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCglibProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"before Proxy......"</span>);</span><br><span class="line">    UserServiceImpl userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">    userService.saveUser(<span class="string">"zby"</span>, <span class="string">"1234567890"</span>);</span><br><span class="line">    System.out.println(<span class="string">"引入Cglib  Proxy代理库 后......"</span>);</span><br><span class="line">    UserServiceImpl proxyUserService = (UserServiceImpl) CglibProxyGenerator</span><br><span class="line">        .generatorCglibProxy(userService, <span class="keyword">new</span> CustomAspect());</span><br><span class="line">    proxyUserService.saveUser(<span class="string">"zby"</span>, <span class="string">"1234567890"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AspectJ-实现-AOP-效果"><a href="#AspectJ-实现-AOP-效果" class="headerlink" title="AspectJ 实现 AOP 效果"></a>AspectJ 实现 AOP 效果</h3><p>AOP 实现的关键就在于 AOP 框架自动创建的 AOP 代理，AOP 代理则可分为静态代理和动态代理两大类:</p><ul><li>静态代理是指使用 AOP 框架提供的命令进行编译，从而在编译阶段通过AOP框架指令生成 AOP 代理类，因此也称为编译时增强；还有一种静态代理是编写代码实现不用工具；这种方式一般是代理模式会使用。</li><li>动态代理则在运行时借助于 JDK 动态代理、CGLIB 等在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。</li></ul><h4 id="基于-AspectJ-的编译时增强进行-AOP-POM-依赖"><a href="#基于-AspectJ-的编译时增强进行-AOP-POM-依赖" class="headerlink" title="基于 AspectJ 的编译时增强进行 AOP POM 依赖"></a>基于 AspectJ 的编译时增强进行 AOP POM 依赖</h4><p>原生 AspectJ 不依赖Spring案例, 基于 AspectJ 的编译时增强进行 AOP 它是在编译期修改字节码，增强功能；并不会生成新的代理类字节码。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- AspectJ begin--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjrt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- AspectJ stop--&gt;</span></span><br></pre></td></tr></table></figure><h2 id="动态代理-使用场景"><a href="#动态代理-使用场景" class="headerlink" title="动态代理 使用场景"></a>动态代理 使用场景</h2><ul><li>日志集中打印</li><li>事务</li><li>权限管理</li><li>AOP</li></ul><blockquote><p><strong>原文链接：</strong><a href="https://cloud.tencent.com/developer/article/1461796" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1461796</a></p></blockquote></div><div class="popular-posts-header">相关文章</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/posts/73c8edbb/" rel="bookmark">EL表达式fn:endsWith函数的bug</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/posts/f07e5cea/" rel="bookmark">JAVA不借助中间变量交换2个变量的值</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/posts/d1d33620/" rel="bookmark">Java 9 中的 9 个新特性</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/posts/cd7a25a4/" rel="bookmark">Java7和Java8中的ConcurrentHashMap原理解析</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/posts/9cb319e/" rel="bookmark">Java7和Java8中的HashMap原理解析</a></div></li></ul><div class="followme"><p>欢迎关注我的其它发布渠道</p><div class="social-list"><div class="social-item"><a target="_blank" class="social-link" href="https://t.me/Eason"><span class="icon"><i class="fab fa-telegram"></i></span> <span class="label">Telegram</span></a></div><div class="social-item"><a target="_blank" class="social-link" href="/atom.xml"><span class="icon"><i class="fa fa-rss"></i></span> <span class="label">RSS</span></a></div></div></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/Java/" rel="tag"># Java</a> <a href="/tags/Proxy/" rel="tag"># Proxy</a> <a href="/tags/CGlib/" rel="tag"># CGlib</a> <a href="/tags/AOP/" rel="tag"># AOP</a></div><div class="post-widgets"><div class="wp_rating"><div id="wpac-rating"></div></div></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/1a9710e/" rel="prev" title="Spring中使用logback打印日志，替换其他日志如log4j,commons-logging"><i class="fa fa-chevron-left"></i> Spring中使用logback打印日志，替换其他日志如log4j,commons-logging</a></div><div class="post-nav-item"> <a href="/posts/73c8edbb/" rel="next" title="EL表达式fn:endsWith函数的bug">EL表达式fn:endsWith函数的bug<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-代理模式实现方式，主要有如下五种方法"><span class="nav-number">1.</span> <span class="nav-text">Java 代理模式实现方式，主要有如下五种方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Notes"><span class="nav-number">2.</span> <span class="nav-text">Notes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#静态代理实现"><span class="nav-number">3.</span> <span class="nav-text">静态代理实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实现步骤"><span class="nav-number">3.1.</span> <span class="nav-text">实现步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Cat接口"><span class="nav-number">3.1.1.</span> <span class="nav-text">Cat接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#委托类-Lion"><span class="nav-number">3.1.2.</span> <span class="nav-text">委托类 Lion</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代理类角色-FeederProxy"><span class="nav-number">3.1.3.</span> <span class="nav-text">代理类角色(FeederProxy)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#静态代理类测试"><span class="nav-number">3.1.4.</span> <span class="nav-text">静态代理类测试</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态代理类-基于接口实现"><span class="nav-number">4.</span> <span class="nav-text">动态代理类(基于接口实现)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#动态代理类涉及角色"><span class="nav-number">4.1.</span> <span class="nav-text">动态代理类涉及角色</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于JDK技术-动态代理类技术核心-Proxy类和一个-InvocationHandler-接口"><span class="nav-number">4.2.</span> <span class="nav-text">基于JDK技术 动态代理类技术核心 Proxy类和一个 InvocationHandler 接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#案例"><span class="nav-number">4.2.1.</span> <span class="nav-text">案例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#公共接口"><span class="nav-number">4.2.1.1.</span> <span class="nav-text">公共接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#具体实现类，等下被委托，被代理的类-SoftwareEngineer-java"><span class="nav-number">4.2.1.2.</span> <span class="nav-text">具体实现类，等下被委托，被代理的类 SoftwareEngineer.java</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#InvocationHandler-接口实现-PersonInvocationHandler-java"><span class="nav-number">4.2.1.3.</span> <span class="nav-text">InvocationHandler 接口实现 PersonInvocationHandler.java</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#PersonInvocationHandler-invoke-方法中添加的公共代码，这里简单以统计方法执行时间为逻辑"><span class="nav-number">4.2.1.4.</span> <span class="nav-text">PersonInvocationHandler invoke 方法中添加的公共代码，这里简单以统计方法执行时间为逻辑</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#最后的是-怎么创建代理类"><span class="nav-number">4.2.1.5.</span> <span class="nav-text">最后的是 怎么创建代理类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解析JDK生成的动态代理类"><span class="nav-number">4.2.2.</span> <span class="nav-text">解析JDK生成的动态代理类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#一个典型的基于JDK动态代理创建对象过程可分为以下四个步骤："><span class="nav-number">4.2.3.</span> <span class="nav-text">一个典型的基于JDK动态代理创建对象过程可分为以下四个步骤：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK动态代理特点总结"><span class="nav-number">4.2.4.</span> <span class="nav-text">JDK动态代理特点总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK动态代理不足"><span class="nav-number">4.2.5.</span> <span class="nav-text">JDK动态代理不足</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于CGlib-技术动态代理代理类实现-基于继承"><span class="nav-number">4.3.</span> <span class="nav-text">基于CGlib 技术动态代理代理类实现 (基于继承)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#导入maven-依赖"><span class="nav-number">4.3.1.</span> <span class="nav-text">导入maven 依赖</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#业务类实现"><span class="nav-number">4.3.2.</span> <span class="nav-text">业务类实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法拦截器-实现-MethodInterceptor-接口"><span class="nav-number">4.3.3.</span> <span class="nav-text">方法拦截器 实现 MethodInterceptor 接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#一个切面，用于在方法拦截器中intercept-方法中调用真正业务方法之前-之后处理逻辑"><span class="nav-number">4.3.4.</span> <span class="nav-text">一个切面，用于在方法拦截器中intercept 方法中调用真正业务方法之前 之后处理逻辑</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Cglib测试类"><span class="nav-number">4.3.5.</span> <span class="nav-text">Cglib测试类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Cglib-总结"><span class="nav-number">4.3.6.</span> <span class="nav-text">Cglib 总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#静态代理-基于JDK动态代理-基于Cglib-动态代理"><span class="nav-number">5.</span> <span class="nav-text">静态代理 基于JDK动态代理 基于Cglib 动态代理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOP-实现案例"><span class="nav-number">6.</span> <span class="nav-text">AOP 实现案例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK动态代理-aop-实现方式"><span class="nav-number">6.1.</span> <span class="nav-text">JDK动态代理 aop 实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#定义切面接口，完成将通用公共方法注入到被代理类接口调用处理中"><span class="nav-number">6.1.1.</span> <span class="nav-text">定义切面接口，完成将通用公共方法注入到被代理类接口调用处理中</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#定义切面实现类"><span class="nav-number">6.1.2.</span> <span class="nav-text">定义切面实现类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#定义切点角色接口-因为是基于JDK实现的Aop-，所以委托类需要基于接口实现。"><span class="nav-number">6.1.3.</span> <span class="nav-text">定义切点角色接口 因为是基于JDK实现的Aop ，所以委托类需要基于接口实现。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#委托类实现"><span class="nav-number">6.1.4.</span> <span class="nav-text">委托类实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK动态代理生成器工具类"><span class="nav-number">6.1.5.</span> <span class="nav-text">JDK动态代理生成器工具类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#测试类"><span class="nav-number">6.1.6.</span> <span class="nav-text">测试类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cglib-aop-实现方式"><span class="nav-number">6.2.</span> <span class="nav-text">Cglib aop 实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#定义切面接口"><span class="nav-number">6.2.1.</span> <span class="nav-text">定义切面接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#切面实现"><span class="nav-number">6.2.2.</span> <span class="nav-text">切面实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Cglib-是基于类实现的动态代理即业务类只需要实现类即可，不用强制必须实现某个接口为了突出这个优点这里没有实现接口"><span class="nav-number">6.2.3.</span> <span class="nav-text">Cglib 是基于类实现的动态代理即业务类只需要实现类即可，不用强制必须实现某个接口为了突出这个优点这里没有实现接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Cglib-动态代理生成器工具类"><span class="nav-number">6.2.4.</span> <span class="nav-text">Cglib 动态代理生成器工具类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#测试类-1"><span class="nav-number">6.2.5.</span> <span class="nav-text">测试类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AspectJ-实现-AOP-效果"><span class="nav-number">6.3.</span> <span class="nav-text">AspectJ 实现 AOP 效果</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基于-AspectJ-的编译时增强进行-AOP-POM-依赖"><span class="nav-number">6.3.1.</span> <span class="nav-text">基于 AspectJ 的编译时增强进行 AOP POM 依赖</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态代理-使用场景"><span class="nav-number">7.</span> <span class="nav-text">动态代理 使用场景</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Zhang Fei" src="https://avatars2.githubusercontent.com/u/16345433?s=40&v=4"><p class="site-author-name" itemprop="name">Zhang Fei</p><div class="site-description" itemprop="description">胡编一通，乱写一气</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">35</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">16</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">42</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="sidebar-button motion-element"><a onclick="tidioChatApi.open()"><i class="fa fa-comment"></i> Chat</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/zhangfei9734" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhangfei9734" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:zhangfei.eason@gmail.com" title="E-Mail → mailto:zhangfei.eason@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i> E-Mail</a></span><span class="links-of-author-item"><a href="https://www.facebook.com/zhangfeicn" title="FB Page → https:&#x2F;&#x2F;www.facebook.com&#x2F;zhangfeicn" rel="noopener" target="_blank"><i class="fab fa-facebook fa-fw"></i> FB Page</a></span><span class="links-of-author-item"><a href="https://stackoverflow.com/users/7614492/eason-zhang" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;7614492&#x2F;eason-zhang" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i> StackOverflow</a></span></div></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; 2016 – <span itemprop="copyrightYear">2020</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Zhang Fei</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-chart-area"></i></span> <span title="站点总字数">222k</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span title="站点阅读时长">3:22</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动</div><div class="addthis_inline_share_toolbox"><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5dbb98e1e900ca44" async="async"></script></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span> <span class="post-meta-divider">|</span><span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div style="display:none"><script src="//s95.cnzz.com/z_stat.php?id=1278303802&web_id=1278303802"></script></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script><script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script>!function(){var o,n,e=document.getElementsByTagName("link");if(0<e.length)for(i=0;i<e.length;i++)"canonical"==e[i].rel.toLowerCase()&&e[i].href&&(o=e[i].href);n=o?o.split(":")[0]:window.location.protocol.split(":")[0],o||(o=window.location.href),function(){var e=o,i=document.referrer;if(!/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(e)){var t="https"===String(n).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";i?(t+="?r="+encodeURIComponent(document.referrer),e&&(t+="&l="+e)):e&&(t+="?l="+e),(new Image).src=t}}(window)}()</script><script>CONFIG.page.isPost&&(wpac_init=window.wpac_init||[],wpac_init.push({widget:"Rating",id:21709,el:"wpac-rating",color:"fc6423"}),function(){if(!("WIDGETPACK_LOADED"in window)){WIDGETPACK_LOADED=!0;var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//embed.widgetpack.com/widget.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t.nextSibling)}}())</script><script src="/js/local-search.js"></script><script src="//code.tidio.co/ce7gqx8qiu8j5bijv6g026uzwtznfabv.js"></script><script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script><script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'http://zhangfei.men/posts/3a5f5aec/',]
      });
      });
  </script><script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : '4lGJ1v9lzpF1QOO20kGGoKpB-gzGzoHsz',
      appKey     : 'TBNkObI72zlxA5z1ToT6xtu8',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/hijiki.model.json"},display:{position:"right",width:150,height:300},mobile:{show:!0},react:{opacity:.7},log:!1})</script></body></html>